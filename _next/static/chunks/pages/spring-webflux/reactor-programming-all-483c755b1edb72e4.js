(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[412],{4753:function(e,r,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/spring-webflux/reactor-programming-all",function(){return n(87)}])},87:function(e,r,n){"use strict";n.r(r),n.d(r,{__toc:function(){return s}});var a=n(5893),i=n(2673),t=n(373),o=n(8426);n(9128);var c=n(2643);let s=[{depth:2,value:"Reactor 프로그래밍 (스압 주의)",id:"reactor-프로그래밍-스압-주의"},{depth:2,value:"Flux, Mono",id:"flux-mono"},{depth:2,value:"sequence",id:"sequence"},{depth:2,value:"subscribe(), Subscriber",id:"subscribe-subscriber"},{depth:2,value:"delayElements()",id:"delayelements"},{depth:2,value:"Error",id:"error"},{depth:2,value:"concat(), merge(), mergeSequential()",id:"concat-merge-mergesequential"},{depth:2,value:"defer()",id:"defer"},{depth:2,value:"defer() 를 flatMap() 으로",id:"defer-를-flatmap-으로"},{depth:2,value:"다양한 함수들",id:"다양한-함수들"},{depth:2,value:"Scheduler, Thread",id:"scheduler-thread"},{depth:2,value:"Context",id:"context"}];function _createMdxContent(e){let r=Object.assign({h2:"h2",p:"p",blockquote:"blockquote",ul:"ul",li:"li",a:"a",code:"code"},(0,c.a)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.h2,{id:"reactor-프로그래밍-스압-주의",children:"Reactor 프로그래밍 (스압 주의)"}),"\n",(0,a.jsxs)(r.p,{children:["Spring Webflux 는 pivotal 사에서 개발한 project reactor 를 기반으로 한 서버 애플리케이션을 개발하기 위한 Web 프레임워크입니다.",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(r.h2,{id:"flux-mono",children:"Flux, Mono"}),"\n",(0,a.jsxs)(r.blockquote,{children:["\n",(0,a.jsx)(r.p,{children:"참고"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:["Flux : ",(0,a.jsx)(r.a,{href:"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html",children:"projectreactor.io - Flux"})]}),"\n",(0,a.jsxs)(r.li,{children:["Mono : ",(0,a.jsx)(r.a,{href:"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html",children:"projectreactor.io - Mono"})]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:["Flux :","\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"Java 의 List 와 유사한 데이터의 흐름입니다. 두개 이상의 데이터의 흐름입니다."}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.a,{href:"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html",children:"projectreactor.io - Flux"})," 을 보면 알 수 있듯 Publisher 를 implements 한 클래스이기에 자료구조라기보다는, 데이터의 흐름이라는 사실을 기억해주시기 바랍니다."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["Mono :","\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"하나만 존재하는 데이터를 의미합니다."}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.a,{href:"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html",children:"projectreactor.io - Mono"})," 을 보면 알 수 있듯 Publisher 를 implements 한 클래스이기에 자료구조라기보다는 데이터의 흐름이라는 사실을 기억해주시기 바랍니다."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(r.p,{children:"Flux 하나만 쓰면 될것 같은데 Mono 가 존재하는 이유에 대해 생각이 들 수 있습니다. Mono 라는 자료형이 존재하는 것으로 인한 장점은 아래와 같습니다."}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"하나만 존재하는 데이터의 흐름(Response, Count 결과값 등) 일 경우 onNext 이후에 바로 onComplete 를 하면 되기 때문에 구현이 더 명확해지게 됩니다."}),"\n",(0,a.jsx)(r.li,{children:"Mono 라는 Publisher 를 받는 Subscriber 측 역시 1개의 요소만 처리해야 한다는 사실을 알 수 있기 때문에 조금 더 구현이 명확해집니다."}),"\n"]}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(r.h2,{id:"sequence",children:"sequence"}),"\n",(0,a.jsxs)(r.p,{children:["여러가지 다양한 sequence 생성",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(r.h2,{id:"subscribe-subscriber",children:"subscribe(), Subscriber"}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(r.h2,{id:"delayelements",children:"delayElements()"}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(r.h2,{id:"error",children:"Error"}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(r.h2,{id:"concat-merge-mergesequential",children:"concat(), merge(), mergeSequential()"}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(r.h2,{id:"defer",children:"defer()"}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(r.h2,{id:"defer-를-flatmap-으로",children:"defer() 를 flatMap() 으로"}),"\n",(0,a.jsx)(r.p,{children:"flatMap() 에서 Supplier 동작을 하려 할 때"}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(r.h2,{id:"다양한-함수들",children:"다양한 함수들"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"map(), mapNotNull()"}),"\n",(0,a.jsx)(r.li,{children:(0,a.jsx)(r.code,{children:"doOn---()"})}),"\n",(0,a.jsx)(r.li,{children:"flatMap()"}),"\n",(0,a.jsx)(r.li,{children:"filter()"}),"\n",(0,a.jsx)(r.li,{children:"take(), takeLast()"}),"\n",(0,a.jsx)(r.li,{children:"skip(), skipLast()"}),"\n",(0,a.jsx)(r.li,{children:"collectList()"}),"\n",(0,a.jsx)(r.li,{children:"cache()"}),"\n"]}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(r.h2,{id:"scheduler-thread",children:"Scheduler, Thread"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"ImmediateScheduler"}),"\n",(0,a.jsx)(r.li,{children:"SingleScheduler"}),"\n",(0,a.jsx)(r.li,{children:"ParallelScheduler"}),"\n",(0,a.jsx)(r.li,{children:"BoundedElasticScheduler"}),"\n"]}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(r.h2,{id:"context",children:"Context"}),"\n",(0,a.jsx)(r.p,{children:"Context 는 파이프라인 내부의 어디에서든 접근 가능한 key, value 저장소입니다. subscribeOn, publishOn 등으로 인해 실행되는 스레드가 달라질 때 Context 를 통해서 특정 key 에 대한 value 를 조회 또는 수정할 수 있습니다.  Map 과 유사한 형식이며, Context 의 종류로는 읽기전용인 ContextView, 쓰기가능한 Context 가 있습니다."}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"contextWrite() : 컨텍스트 쓰기"}),"\n",(0,a.jsx)(r.li,{children:"contextView() : 컨텍스트 읽기"}),"\n",(0,a.jsx)(r.li,{children:"deferContextual()"}),"\n"]}),"\n",(0,a.jsx)("br",{})]})}let d={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,c.a)(),e.components);return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(_createMdxContent,{...e})}):_createMdxContent(e)},pageOpts:{filePath:"pages/spring-webflux/reactor-programming-all.mdx",route:"/spring-webflux/reactor-programming-all",timestamp:1711087969e3,pageMap:[{kind:"Folder",name:"concurrent-programming-basic",route:"/concurrent-programming-basic",children:[{kind:"MdxPage",name:"blocking-vs-nonblocking",route:"/concurrent-programming-basic/blocking-vs-nonblocking"},{kind:"MdxPage",name:"completable-future",route:"/concurrent-programming-basic/completable-future"},{kind:"MdxPage",name:"completable-stage",route:"/concurrent-programming-basic/completable-stage"},{kind:"MdxPage",name:"intro",route:"/concurrent-programming-basic/intro"},{kind:"MdxPage",name:"sync-vs-async",route:"/concurrent-programming-basic/sync-vs-async"},{kind:"Meta",data:{intro:"Intro","sync-vs-async":"동기 vs 비동기","blocking-vs-nonblocking":"블로킹 vs 논 블로킹","completable-future":"CompletableFuture","completable-stage":"CompletableStage"}}]},{kind:"MdxPage",name:"index",route:"/"},{kind:"Folder",name:"kotlin-coroutine",route:"/kotlin-coroutine",children:[{kind:"MdxPage",name:"intro",route:"/kotlin-coroutine/intro"},{kind:"Meta",data:{intro:"Intro"}}]},{kind:"Folder",name:"nio-and-aio",route:"/nio-and-aio",children:[{kind:"MdxPage",name:"intro",route:"/nio-and-aio/intro"},{kind:"MdxPage",name:"java-io-java-nio-java-aio",route:"/nio-and-aio/java-io-java-nio-java-aio"},{kind:"MdxPage",name:"java-nio-socket-communication",route:"/nio-and-aio/java-nio-socket-communication"},{kind:"MdxPage",name:"what-is-aio",route:"/nio-and-aio/what-is-aio"},{kind:"MdxPage",name:"what-is-nio",route:"/nio-and-aio/what-is-nio"},{kind:"Meta",data:{intro:"Intro","java-io-java-nio-java-aio":"Java IO,NIO,AIO","what-is-nio":"NIO 의 개념, 특징, 주요 클래스","java-nio-socket-communication":"Java NIO 소켓통신","what-is-aio":"AIO 의 개념, 특징, 예제"}}]},{kind:"Folder",name:"r2dbc-mysql",route:"/r2dbc-mysql",children:[{kind:"MdxPage",name:"example",route:"/r2dbc-mysql/example"},{kind:"MdxPage",name:"intro",route:"/r2dbc-mysql/intro"},{kind:"MdxPage",name:"what-is-r2dbc",route:"/r2dbc-mysql/what-is-r2dbc"},{kind:"Meta",data:{intro:"Intro","what-is-r2dbc":"R2DBC 란?",example:"예제"}}]},{kind:"Folder",name:"reactive-mongodb",route:"/reactive-mongodb",children:[{kind:"MdxPage",name:"example",route:"/reactive-mongodb/example"},{kind:"MdxPage",name:"intro",route:"/reactive-mongodb/intro"},{kind:"Meta",data:{intro:"Intro",example:"예제"}}]},{kind:"Folder",name:"reactive-programming",route:"/reactive-programming",children:[{kind:"MdxPage",name:"intro",route:"/reactive-programming/intro"},{kind:"MdxPage",name:"java-nio-bad-point-and-solution",route:"/reactive-programming/java-nio-bad-point-and-solution"},{kind:"MdxPage",name:"netflix-rxjava-story",route:"/reactive-programming/netflix-rxjava-story"},{kind:"MdxPage",name:"proactor-pattern",route:"/reactive-programming/proactor-pattern"},{kind:"MdxPage",name:"publisher-subscriber-subscription-backpressure",route:"/reactive-programming/publisher-subscriber-subscription-backpressure"},{kind:"MdxPage",name:"reactive-streams-libraries",route:"/reactive-programming/reactive-streams-libraries"},{kind:"MdxPage",name:"reactor-pattern",route:"/reactive-programming/reactor-pattern"},{kind:"MdxPage",name:"webflux-backpressure-handling",route:"/reactive-programming/webflux-backpressure-handling"},{kind:"MdxPage",name:"what-is-epoll",route:"/reactive-programming/what-is-epoll"},{kind:"MdxPage",name:"what-is-reactive",route:"/reactive-programming/what-is-reactive"},{kind:"Meta",data:{intro:"intro","what-is-reactive":"Reactive란?","netflix-rxjava-story":"Netflix RxJava 이야기","publisher-subscriber-subscription-backpressure":"Publisher,Subscriber,Subscription,Backpressure","reactive-streams-libraries":"Reactive Streams 라이브러리들","webflux-backpressure-handling":"Spring Webflux 에서 Backpressure 핸들링","java-nio-bad-point-and-solution":"Java NIO 의 논블로킹 방식 동기연산의 문제점과 해결책, 멀티플렉싱","what-is-epoll":"epoll 이란?","reactor-pattern":"reactor 패턴","proactor-pattern":"proactor 패턴"}}]},{kind:"Folder",name:"server-sent-event",route:"/server-sent-event",children:[{kind:"MdxPage",name:"intro",route:"/server-sent-event/intro"},{kind:"MdxPage",name:"what-is-sse",route:"/server-sent-event/what-is-sse"},{kind:"Meta",data:{intro:"Intro","what-is-sse":"SSE (Server Sent Event) 개념, Spring Webflux, 예제"}}]},{kind:"Folder",name:"spring-cloud-reactive-circuitbreaker",route:"/spring-cloud-reactive-circuitbreaker",children:[{kind:"MdxPage",name:"intro",route:"/spring-cloud-reactive-circuitbreaker/intro"},{kind:"MdxPage",name:"reactive-circuit-breaker-basic",route:"/spring-cloud-reactive-circuitbreaker/reactive-circuit-breaker-basic"},{kind:"Meta",data:{intro:"Introduce","reactive-circuit-breaker-basic":"Reactive Cricuit Breaker"}}]},{kind:"Folder",name:"spring-cloud-stream-and-kafka",route:"/spring-cloud-stream-and-kafka",children:[{kind:"MdxPage",name:"intro",route:"/spring-cloud-stream-and-kafka/intro"},{kind:"MdxPage",name:"kafka-basic",route:"/spring-cloud-stream-and-kafka/kafka-basic"},{kind:"MdxPage",name:"kafka-docker-compose",route:"/spring-cloud-stream-and-kafka/kafka-docker-compose"},{kind:"MdxPage",name:"spring-cloud-stream-kafka-binder",route:"/spring-cloud-stream-and-kafka/spring-cloud-stream-kafka-binder"},{kind:"MdxPage",name:"spring-cloud-stream",route:"/spring-cloud-stream-and-kafka/spring-cloud-stream"},{kind:"Meta",data:{intro:"Intro","kafka-basic":"Kafka 의 주요 개념들","kafka-docker-compose":"Kafak 로컬 개발환경 (docker-compose)","spring-cloud-stream":"Spring Cloud Stream","spring-cloud-stream-kafka-binder":"Spring Cloud Stream Kafka Binder"}}]},{kind:"Folder",name:"spring-webflux",route:"/spring-webflux",children:[{kind:"MdxPage",name:"annotated-controller",route:"/spring-webflux/annotated-controller"},{kind:"MdxPage",name:"codec",route:"/spring-webflux/codec"},{kind:"MdxPage",name:"dispatcher-handler-communication-spring-webflux",route:"/spring-webflux/dispatcher-handler-communication-spring-webflux"},{kind:"MdxPage",name:"intro",route:"/spring-webflux/intro"},{kind:"MdxPage",name:"reactor-programming-all",route:"/spring-webflux/reactor-programming-all"},{kind:"MdxPage",name:"servlet-stack-vs-reactive-stack",route:"/spring-webflux/servlet-stack-vs-reactive-stack"},{kind:"MdxPage",name:"spring-mvc-vs-spring-webflux",route:"/spring-webflux/spring-mvc-vs-spring-webflux"},{kind:"Meta",data:{intro:"Intro","servlet-stack-vs-reactive-stack":"Servlet Stack vs Reactive Stack","spring-mvc-vs-spring-webflux":"Spring MVC vs Spring Webflux","dispatcher-handler-communication-spring-webflux":"DispatcherHandler 와 Spring Webflux","annotated-controller":"Annotated Controller",codec:"Codec","reactor-programming-all":"Reactor 프로그래밍 (스압 주의)"}}]},{kind:"Folder",name:"webflux-websocket",route:"/webflux-websocket",children:[{kind:"MdxPage",name:"intro",route:"/webflux-websocket/intro"},{kind:"MdxPage",name:"what-is-websocket",route:"/webflux-websocket/what-is-websocket"},{kind:"Meta",data:{intro:"Intro","what-is-websocket":"Websocket 개념, Spring Webflux, 예제"}}]},{kind:"Meta",data:{index:"Introduction","concurrent-programming-basic":"동시성 프로그래밍 개념들","nio-and-aio":"NIO, AIO","reactive-programming":"Reactive Programming","spring-webflux":"Spring Webflux","spring-cloud-stream-and-kafka":"Spring Cloud Stream & Kafka","spring-cloud-reactive-circuitbreaker":"Spring Cloud Reactive Circuit Breaker","kotlin-coroutine":"Kotlin Coroutine","server-sent-event":"Server Sent Event (SSE)","webflux-websocket":"Webflux Websocket","r2dbc-mysql":"Spring Data R2dbc","reactive-mongodb":"Spring Data Reactive Mongodb",contact:{title:"Contact ↗",type:"page",href:"-",newWindow:!0}}}],flexsearch:{codeblocks:!0},title:"Reactor Programming All",headings:s},pageNextRoute:"/spring-webflux/reactor-programming-all",nextraLayout:t.ZP,themeConfig:o.Z};r.default=(0,i.j)(d)},8426:function(e,r,n){"use strict";var a=n(5893);n(7294);let i={logo:(0,a.jsx)("span",{children:"Docs Spring Webflux"}),project:{link:"https://github.com/chagchagchag/docs-spring-webflux"},docsRepositoryBase:"https://github.com/chagchagchag/docs-spring-webflux",footer:{text:"Nextra Docs Template"}};r.Z=i},5789:function(){}},function(e){e.O(0,[9774,6796,2888,179],function(){return e(e.s=4753)}),_N_E=e.O()}]);