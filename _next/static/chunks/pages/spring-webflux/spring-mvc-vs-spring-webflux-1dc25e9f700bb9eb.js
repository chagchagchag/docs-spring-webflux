(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2914],{3244:function(e,r,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/spring-webflux/spring-mvc-vs-spring-webflux",function(){return n(6922)}])},4984:function(e,r){"use strict";r.Z={src:"/docs-spring-webflux/_next/static/media/STACKS.3d243ac5.png",height:764,width:1506,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAAZ0lEQVR42h2MvQqAIBhFff9nCWopbIla6ytEC7EiKxcXZwf/ku54OeegFtdD32mtZxifW6aU4j9UlQXGjTFGXtd5HvsuKCVCcETIwhgNISj1AkwTAOfce4+yld9csNZmaFuZcy7G+AETSlQu5zxxLAAAAABJRU5ErkJggg==",blurWidth:8,blurHeight:4}},6922:function(e,r,n){"use strict";n.r(r),n.d(r,{__toc:function(){return g},default:function(){return p}});var a=n(5893),i=n(2673),t=n(373),o=n(8426);n(9128);var c=n(2643),s={src:"/docs-spring-webflux/_next/static/media/spring-mvc-and-webflux-venn.47d38dd8.png",height:446,width:800,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAAWElEQVR42hWMQQ6AIBAD6a6oMUaJ/3+cd46SgFA24rGdzKDS4lNy5SSipYJct+W8dtwxlUavmlIeLCiM9LMXFTjnAHTSzERkrP95Wx8pc+jDo82AejnC9gFLjSql3MCK1QAAAABJRU5ErkJggg==",blurWidth:8,blurHeight:4},d={src:"/docs-spring-webflux/_next/static/media/REACTIVE-ADAPTER-REGISTRY.ccc9df59.png",height:548,width:1036,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAIAAAA8r+mnAAAAZklEQVR42hWLOQqAMBAA8/+PWIgvEHHjRitPDKKoBOLWqdKZw9gNMwwTopFyHYf+OPZlmbZNFnk2zxNzzt3XWdcVIgIA59wYE0JgMcZERI/WmoiUUtba93V/SFPXIodSICROxnv/AckSU0IvBF8WAAAAAElFTkSuQmCC",blurWidth:8,blurHeight:4},l=n(4984);let g=[{depth:2,value:"Spring MVC vs Spring Webflux",id:"spring-mvc-vs-spring-webflux"},{depth:2,value:"Reactive 구현체와 Reactive Adapter",id:"reactive-구현체와-reactive-adapter"},{depth:2,value:"Spring Reactive Stack 의 구성",id:"spring-reactive-stack-의-구성"}];function _createMdxContent(e){let r=Object.assign({h2:"h2",p:"p",a:"a",img:"img",ol:"ol",li:"li",strong:"strong"},(0,c.a)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.h2,{id:"spring-mvc-vs-spring-webflux",children:"Spring MVC vs Spring Webflux"}),"\n",(0,a.jsxs)(r.p,{children:["참고 : ",(0,a.jsx)(r.a,{href:"https://docs.spring.io/spring-framework/reference/web/webflux/new-framework.html",children:"https://docs.spring.io/spring-framework/reference/web/webflux/new-framework.html"})]}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(r.p,{children:(0,a.jsx)(r.img,{placeholder:"blur",src:s})}),"\n",(0,a.jsxs)(r.p,{children:["Spring Webflux 에서도 Annotated Controller 라고 불리는 @Controller를 사용가능합니다. Spring MVC 에서도 Spring Webflux 의 Reactive Client 를 사용가능합니다. 그리고 Spring Webflux 에서도 Tomcat, Jetty, Undertow 등을 사용 가능합니다.",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(r.h2,{id:"reactive-구현체와-reactive-adapter",children:"Reactive 구현체와 Reactive Adapter"}),"\n",(0,a.jsxs)(r.p,{children:["Reactor, RxJava, Mutiny, kotlin coroutine 등과 같은 Reactive Streams 구현체는 모두 Reactive Streams 의 Publiser 타입으로 호환이 가능합니다. 그리고 이 Publisher 는 ReactiveAdapter 를 통해서 적용이 되며, Reactive AdapterRegistry 에 등록되어서 여러 종류의 Reactive Streams 구현체를 사용하는 것이 가능합니다.",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(r.p,{children:(0,a.jsx)(r.img,{placeholder:"blur",src:d})}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(r.h2,{id:"spring-reactive-stack-의-구성",children:"Spring Reactive Stack 의 구성"}),"\n",(0,a.jsx)(r.p,{children:(0,a.jsx)(r.img,{placeholder:"blur",src:l.Z})}),"\n",(0,a.jsx)("br",{}),"\n",(0,a.jsx)(r.p,{children:"Reactor 기반의 Netty 를 사용한다면 Reactor Netty 를 사용하게 됩니다. Reactor Netty 는 Netty 를 Reactor 기반으로 조합성,편의성을 크게 확장한 WAS 컨테이너 입니다."}),"\n",(0,a.jsxs)(r.p,{children:["Reactor 는 Pivotal 사에서 공식적으로 제공한 Reactive Streams 구현체 라이브러리입니다.",(0,a.jsx)("br",{})]}),"\n",(0,a.jsxs)(r.p,{children:["Spring Webflux 는  Servlet 기반 웹 애플리케이션의 동기적인 처리 방식 대신 비동기 및 반응형 프로그래밍 모델을 제공합니다. Spring WebFlux는 Java 8의 CompletableFuture 및 Reactor 프로젝트를 기반으로 한 리액티브 라이브러리를 활용하여 구현되어있는 Spring Web 을 위한 반응형 프로그래밍 라이브러리 입니다.",(0,a.jsx)("br",{})]}),"\n",(0,a.jsx)(r.p,{children:"Spring Webflux 의 주요특징, 개념은 아래와 같습니다."}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"비동기 및 반응형 프로그래밍:"})," Spring WebFlux는 비동기적이며 반응형 프로그래밍 모델을 채택합니다. 이는 높은 동시성과 확장성을 제공하며, 논블로킹 I/O를 활용하여 더 많은 동시 요청을 처리할 수 있습니다."]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Reactor 라이브러리:"})," Spring WebFlux는 Reactor 라이브러리를 기반으로 하여, Flux와 Mono라는 리액티브 타입을 제공합니다. Flux는 여러 개의 데이터를 처리하는 데 사용되고, Mono는 0 또는 1개의 데이터를 처리하는 데 사용됩니다."]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"함수형 엔드포인트:"})," Spring WebFlux는 기존의 컨트롤러 대신 함수형 엔드포인트를 제공합니다. 이는 람다 표현식이나 Java 8의 함수형 인터페이스를 사용하여 간결하고 가독성 있는 코드를 작성할 수 있게 합니다."]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"반응형 서버 및 클라이언트:"})," Spring WebFlux는 반응형 서버와 클라이언트를 모두 제공합니다. 서버 측에서는 Netty와 같은 서버를 이용하여 비동기적으로 요청을 처리하고, 클라이언트 측에서는 WebClient를 통해 외부 서비스에 비동기적으로 요청을 보낼 수 있습니다."]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"어노테이션 기반의 라우팅:"})," Spring WebFlux는 기존의 Spring MVC와 유사한 어노테이션 기반의 라우팅을 지원하여 빠르게 웹 애플리케이션을 개발할 수 있습니다."]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"모노리틱 및 마이크로서비스 아키텍처 지원:"})," Spring WebFlux는 단일 서버에서 실행되는 전통적인 모노리틱 애플리케이션부터 분산된 마이크로서비스 아키텍처까지 다양한 환경에서 사용할 수 있습니다."]}),"\n"]}),"\n",(0,a.jsx)("br",{})]})}let u={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,c.a)(),e.components);return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(_createMdxContent,{...e})}):_createMdxContent(e)},pageOpts:{filePath:"pages/spring-webflux/spring-mvc-vs-spring-webflux.mdx",route:"/spring-webflux/spring-mvc-vs-spring-webflux",timestamp:1710144426e3,pageMap:[{kind:"Folder",name:"concurrent-programming-basic",route:"/concurrent-programming-basic",children:[{kind:"MdxPage",name:"blocking-vs-nonblocking",route:"/concurrent-programming-basic/blocking-vs-nonblocking"},{kind:"MdxPage",name:"completable-future",route:"/concurrent-programming-basic/completable-future"},{kind:"MdxPage",name:"completable-stage",route:"/concurrent-programming-basic/completable-stage"},{kind:"MdxPage",name:"intro",route:"/concurrent-programming-basic/intro"},{kind:"MdxPage",name:"sync-vs-async",route:"/concurrent-programming-basic/sync-vs-async"},{kind:"Meta",data:{intro:"Intro","sync-vs-async":"동기 vs 비동기","blocking-vs-nonblocking":"블로킹 vs 논 블로킹","completable-future":"CompletableFuture","completable-stage":"CompletableStage"}}]},{kind:"MdxPage",name:"index",route:"/"},{kind:"Folder",name:"kotlin-coroutine",route:"/kotlin-coroutine",children:[{kind:"MdxPage",name:"intro",route:"/kotlin-coroutine/intro"},{kind:"Meta",data:{intro:"Intro"}}]},{kind:"Folder",name:"nio-and-aio",route:"/nio-and-aio",children:[{kind:"MdxPage",name:"intro",route:"/nio-and-aio/intro"},{kind:"MdxPage",name:"java-io-java-nio-java-aio",route:"/nio-and-aio/java-io-java-nio-java-aio"},{kind:"MdxPage",name:"java-nio-socket-communication",route:"/nio-and-aio/java-nio-socket-communication"},{kind:"MdxPage",name:"what-is-aio",route:"/nio-and-aio/what-is-aio"},{kind:"MdxPage",name:"what-is-nio",route:"/nio-and-aio/what-is-nio"},{kind:"Meta",data:{intro:"Intro","java-io-java-nio-java-aio":"Java IO,NIO,AIO","what-is-nio":"NIO 의 개념, 특징, 주요 클래스","java-nio-socket-communication":"Java NIO 소켓통신","what-is-aio":"AIO 의 개념, 특징, 예제"}}]},{kind:"Folder",name:"r2dbc-mysql",route:"/r2dbc-mysql",children:[{kind:"MdxPage",name:"example",route:"/r2dbc-mysql/example"},{kind:"MdxPage",name:"intro",route:"/r2dbc-mysql/intro"},{kind:"MdxPage",name:"what-is-r2dbc",route:"/r2dbc-mysql/what-is-r2dbc"},{kind:"Meta",data:{intro:"Intro","what-is-r2dbc":"R2DBC 란?",example:"예제"}}]},{kind:"Folder",name:"reactive-mongodb",route:"/reactive-mongodb",children:[{kind:"MdxPage",name:"example",route:"/reactive-mongodb/example"},{kind:"MdxPage",name:"intro",route:"/reactive-mongodb/intro"},{kind:"Meta",data:{intro:"Intro",example:"예제"}}]},{kind:"Folder",name:"reactive-programming",route:"/reactive-programming",children:[{kind:"MdxPage",name:"intro",route:"/reactive-programming/intro"},{kind:"MdxPage",name:"java-nio-bad-point-and-solution",route:"/reactive-programming/java-nio-bad-point-and-solution"},{kind:"MdxPage",name:"netflix-rxjava-story",route:"/reactive-programming/netflix-rxjava-story"},{kind:"MdxPage",name:"proactor-pattern",route:"/reactive-programming/proactor-pattern"},{kind:"MdxPage",name:"publisher-subscriber-subscription-backpressure",route:"/reactive-programming/publisher-subscriber-subscription-backpressure"},{kind:"MdxPage",name:"reactive-streams-libraries",route:"/reactive-programming/reactive-streams-libraries"},{kind:"MdxPage",name:"reactor-pattern",route:"/reactive-programming/reactor-pattern"},{kind:"MdxPage",name:"webflux-backpressure-handling",route:"/reactive-programming/webflux-backpressure-handling"},{kind:"MdxPage",name:"what-is-epoll",route:"/reactive-programming/what-is-epoll"},{kind:"MdxPage",name:"what-is-reactive",route:"/reactive-programming/what-is-reactive"},{kind:"Meta",data:{intro:"intro","what-is-reactive":"Reactive란?","netflix-rxjava-story":"Netflix RxJava 이야기","publisher-subscriber-subscription-backpressure":"Publisher,Subscriber,Subscription,Backpressure","reactive-streams-libraries":"Reactive Streams 라이브러리들","webflux-backpressure-handling":"Spring Webflux 에서 Backpressure 핸들링","java-nio-bad-point-and-solution":"Java NIO 의 논블로킹 방식 동기연산의 문제점과 해결책, 멀티플렉싱","what-is-epoll":"epoll 이란?","reactor-pattern":"reactor 패턴","proactor-pattern":"proactor 패턴"}}]},{kind:"Folder",name:"server-sent-event",route:"/server-sent-event",children:[{kind:"MdxPage",name:"example",route:"/server-sent-event/example"},{kind:"MdxPage",name:"intro",route:"/server-sent-event/intro"},{kind:"MdxPage",name:"what-is-sse",route:"/server-sent-event/what-is-sse"},{kind:"Meta",data:{intro:"Intro","what-is-sse":"SSE (Server Sent Event) 의 개념",example:"예제코드"}}]},{kind:"Folder",name:"spring-cloud-reactive-circuitbreaker",route:"/spring-cloud-reactive-circuitbreaker",children:[{kind:"MdxPage",name:"intro",route:"/spring-cloud-reactive-circuitbreaker/intro"},{kind:"MdxPage",name:"reactive-circuit-breaker-basic",route:"/spring-cloud-reactive-circuitbreaker/reactive-circuit-breaker-basic"},{kind:"Meta",data:{intro:"Introduce","reactive-circuit-breaker-basic":"Reactive Cricuit Breaker"}}]},{kind:"Folder",name:"spring-cloud-stream-and-kafka",route:"/spring-cloud-stream-and-kafka",children:[{kind:"MdxPage",name:"intro",route:"/spring-cloud-stream-and-kafka/intro"},{kind:"MdxPage",name:"kafka-basic",route:"/spring-cloud-stream-and-kafka/kafka-basic"},{kind:"MdxPage",name:"kafka-docker-compose",route:"/spring-cloud-stream-and-kafka/kafka-docker-compose"},{kind:"MdxPage",name:"spring-cloud-stream-kafka-binder",route:"/spring-cloud-stream-and-kafka/spring-cloud-stream-kafka-binder"},{kind:"MdxPage",name:"spring-cloud-stream",route:"/spring-cloud-stream-and-kafka/spring-cloud-stream"},{kind:"Meta",data:{intro:"Intro","kafka-basic":"Kafka 의 주요 개념들","kafka-docker-compose":"Kafak 로컬 개발환경 (docker-compose)","spring-cloud-stream":"Spring Cloud Stream","spring-cloud-stream-kafka-binder":"Spring Cloud Stream Kafka Binder"}}]},{kind:"Folder",name:"spring-webflux",route:"/spring-webflux",children:[{kind:"MdxPage",name:"annotated-controller",route:"/spring-webflux/annotated-controller"},{kind:"MdxPage",name:"codec",route:"/spring-webflux/codec"},{kind:"MdxPage",name:"dispatcher-handler-communication-spring-webflux",route:"/spring-webflux/dispatcher-handler-communication-spring-webflux"},{kind:"MdxPage",name:"intro",route:"/spring-webflux/intro"},{kind:"MdxPage",name:"servlet-stack-vs-reactive-stack",route:"/spring-webflux/servlet-stack-vs-reactive-stack"},{kind:"MdxPage",name:"spring-mvc-vs-spring-webflux",route:"/spring-webflux/spring-mvc-vs-spring-webflux"},{kind:"Meta",data:{intro:"Intro","servlet-stack-vs-reactive-stack":"Servlet Stack vs Reactive Stack","spring-mvc-vs-spring-webflux":"Spring MVC vs Spring Webflux","dispatcher-handler-communication-spring-webflux":"DispatcherHandler 와 Spring Webflux","annotated-controller":"Annotated Controller",codec:"Codec"}}]},{kind:"Folder",name:"webflux-websocket",route:"/webflux-websocket",children:[{kind:"MdxPage",name:"example",route:"/webflux-websocket/example"},{kind:"MdxPage",name:"intro",route:"/webflux-websocket/intro"},{kind:"Meta",data:{intro:"Intro",example:"예제"}}]},{kind:"Meta",data:{index:"Introduction","concurrent-programming-basic":"동시성 프로그래밍 개념들","nio-and-aio":"NIO, AIO","reactive-programming":"Reactive Programming","spring-webflux":"Spring Webflux","spring-cloud-stream-and-kafka":"Spring Cloud Stream & Kafka","spring-cloud-reactive-circuitbreaker":"Spring Cloud Reactive Circuit Breaker","kotlin-coroutine":"Kotlin Coroutine","server-sent-event":"Server Sent Event (SSE)","webflux-websocket":"Webflux Websocket","r2dbc-mysql":"Spring Data R2dbc","reactive-mongodb":"Spring Data Reactive Mongodb",contact:{title:"Contact ↗",type:"page",href:"-",newWindow:!0}}}],flexsearch:{codeblocks:!0},title:"Spring Mvc Vs Spring Webflux",headings:g},pageNextRoute:"/spring-webflux/spring-mvc-vs-spring-webflux",nextraLayout:t.ZP,themeConfig:o.Z};var p=(0,i.j)(u)},8426:function(e,r,n){"use strict";var a=n(5893);n(7294);let i={logo:(0,a.jsx)("span",{children:"Docs Spring Webflux"}),project:{link:"https://github.com/chagchagchag/docs-spring-webflux"},docsRepositoryBase:"https://github.com/chagchagchag/docs-spring-webflux",footer:{text:"Nextra Docs Template"}};r.Z=i},5789:function(){}},function(e){e.O(0,[9774,6796,2888,179],function(){return e(e.s=3244)}),_N_E=e.O()}]);