(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[866],{7164:function(e,a,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/reactive-programming/java-nio-bad-point-and-solution",function(){return n(8185)}])},8185:function(e,a,n){"use strict";n.r(a),n.d(a,{__toc:function(){return l},default:function(){return m}});var r=n(5893),i=n(2673),t=n(373),o=n(8426);n(9128);var s=n(2643),d={src:"/docs-spring-webflux/_next/static/media/busy-wait.da69584b.png",height:650,width:360,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAIBAMAAAAsHUM2AAAAJ1BMVEX////+/v79/f38/f38/Pz7+/v6+vr5+vr5+fr5+fn4+Pj39/f19fXXOX6VAAAAIElEQVR42mPQymRwSmVIC2RwKGIIOckgsoOBwZBBIAkAQQ8FMGPErL8AAAAASUVORK5CYII=",blurWidth:4,blurHeight:8},c={src:"/docs-spring-webflux/_next/static/media/selectable-channel-multiplexing.704538b8.png",height:684,width:1007,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAMAAABPT11nAAAASFBMVEX////+/v79/f38/Pz7+/v6+vr5+fn19fb09PTy8vLw8PDs7Ozr6+vp6enn5+bj4+Pc3NzY2NjOzc3Dw8LAv76wr62vrqyqqaYMHd1PAAAALklEQVR42hXEhQ0AMAzEwE+ZGfbftI1lHQj2DBDxQrIAGYWfzi76UBTqbWv2nR4QrQEgo0qovQAAAABJRU5ErkJggg==",blurWidth:8,blurHeight:5};let l=[{depth:2,value:"Java NIO 의 논블로킹 방식 동기연산의 문제점과 해결책, 멀티플렉싱",id:"java-nio-의-논블로킹-방식-동기연산의-문제점과-해결책-멀티플렉싱"},{depth:2,value:"Busy Waiting",id:"busy-waiting"},{depth:2,value:"해결책 : 여러개의 Channel 을 Selector 로 Multiplexing",id:"해결책--여러개의-channel-을-selector-로-multiplexing"},{depth:2,value:"예제 (NIO Socket Programming)",id:"예제-nio-socket-programming"}];function _createMdxContent(e){let a=Object.assign({h2:"h2",blockquote:"blockquote",p:"p",a:"a",img:"img"},(0,s.a)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.h2,{id:"java-nio-의-논블로킹-방식-동기연산의-문제점과-해결책-멀티플렉싱",children:"Java NIO 의 논블로킹 방식 동기연산의 문제점과 해결책, 멀티플렉싱"}),"\n",(0,r.jsx)(a.h2,{id:"busy-waiting",children:"Busy Waiting"}),"\n",(0,r.jsxs)(a.blockquote,{children:["\n",(0,r.jsxs)(a.p,{children:[(0,r.jsx)(a.a,{href:"https://nesoy.github.io/articles/2019-06/OS-Busy-Waiting",children:"참고 : Busy Waiting이란?"}),(0,r.jsx)("br",{})]}),"\n"]}),"\n",(0,r.jsxs)(a.p,{children:["Java NIO 는 논블로킹 방식이지만 동기연산이 필요합니다. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.p,{children:["논블로킹 방식이지만 동기연산을 수행하기 때문에 IO 작업시 특정 루프 내에서 주기적으로 상태를 체크하고 자원관리를 해줘야 한다는 단점이 있습니다. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.p,{children:["이렇게 오랜 시간 동안 대기하면서 상태를 체크하는 것을 Busy Waiting 이라고 흔히 이야기 합니다. Busy Waiting 은 원하는 자원을 얻기 위해 권한을 얻을 수 있을때까지 주기적으로 체크를 수행하는 것을 의미합니다. 자원의 권한을 얻는데 드는 시간이 적거나, Context Switching 에 맡기기에는 가변운 작업일 경우에 Busy Waiting 을 하는 것을 선택합니다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.p,{children:["이렇게 되면 지속적으로 CPU 를 점유하게 되므로 CPU 자원이 낭비된다는 단점이 있습니다. 그리고 확인하는 주기가 어떻게 되느냐에 따라서 응답 지연 시간 역시 어느 정도 발생하게 됩니다. 또한 코드의 복잡성이 증가합니다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(a.p,{children:(0,r.jsx)(a.img,{placeholder:"blur",src:d})}),"\n",(0,r.jsxs)(a.p,{children:["Busy Waiting 을 하는 프로그램의 예를 들면 소켓 프로그램을 구현시 main 스레드에서 accept()가 되었는지 주기적으로 확인하는 구문을 작성하는 경우를 예로 들 수 있습니다. 이렇게 되면 채널 상태의 변화에 따라서 수동으로 상태를 체크하거나 특정 상태에 따라서 후 처리를 하는 등의 관리를 해야 하기 때문에 코드의 복잡성이 계속해서 증가하게 됩니다. 따라서 동시에 발생하는 요청이 증가할 경우 성능이 감소할 위험이 있습니다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)("br",{}),"\n",(0,r.jsx)(a.h2,{id:"해결책--여러개의-channel-을-selector-로-multiplexing",children:"해결책 : 여러개의 Channel 을 Selector 로 Multiplexing"}),"\n",(0,r.jsxs)(a.p,{children:["일반적으로 멀티플렉싱은 하나의 고 수준의 채널에서 저 수준의 채널들을 분류해주고 관리해주는 것을 의미합니다. NIO 에서 I/O Multiplexing 은 여러개의 Channel 을 하나의 Selector 로 관리하는 것을 의미합니다. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(a.p,{children:(0,r.jsx)(a.img,{placeholder:"blur",src:c})}),"\n",(0,r.jsxs)(a.p,{children:["그림에서 보듯 Channel 들은 각각 Selector 에 자기 자신을 등록합니다. 그리고 Selector 는 Thread 를 선택해서 Thread 자원을 관리하고 있습니다. 즉, IO 입력 하나 하나가 Thread 를 가지고 있는 것이 아니라 Selector 에서 Thread 를 관리하면서 Selector 들을 선택하고 체크하는 역할을 수행합니다. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.p,{children:["이렇게 하는 것의 장점은 개별 IO 작업이 BUSY WAITING 으로 인한 자원의 과소비를 Selector 하나만으로 이 작업을 수행하게 함으로써 BUSY WAITING 을 줄였다는 점이 장점입니다. Selector 는 여러개 있을 수 있습니다. ",(0,r.jsx)("br",{})]}),"\n",(0,r.jsxs)(a.p,{children:["개별 Channel 이 가각 Thread 를 잡고 있는다거나 CPU를 과도하게 점유하는 것으로 인한 자원의 과소비나 BUSY WAITING 현상이 줄어들기에 Selector 를 활용한 Channel Multiplexing 개념은 Java NIO 의 논블로킹 방식의 동기 연산의 단점인 Busy Waiting 현상을 대폭 줄여주었습니다.",(0,r.jsx)("br",{})]}),"\n",(0,r.jsx)(a.h2,{id:"예제-nio-socket-programming",children:"예제 (NIO Socket Programming)"})]})}let g={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:a}=Object.assign({},(0,s.a)(),e.components);return a?(0,r.jsx)(a,{...e,children:(0,r.jsx)(_createMdxContent,{...e})}):_createMdxContent(e)},pageOpts:{filePath:"pages/reactive-programming/java-nio-bad-point-and-solution.mdx",route:"/reactive-programming/java-nio-bad-point-and-solution",timestamp:171012622e4,pageMap:[{kind:"Folder",name:"concurrent-programming-basic",route:"/concurrent-programming-basic",children:[{kind:"MdxPage",name:"blocking-vs-nonblocking",route:"/concurrent-programming-basic/blocking-vs-nonblocking"},{kind:"MdxPage",name:"completable-future",route:"/concurrent-programming-basic/completable-future"},{kind:"MdxPage",name:"completable-stage",route:"/concurrent-programming-basic/completable-stage"},{kind:"MdxPage",name:"intro",route:"/concurrent-programming-basic/intro"},{kind:"MdxPage",name:"sync-vs-async",route:"/concurrent-programming-basic/sync-vs-async"},{kind:"Meta",data:{intro:"Intro","sync-vs-async":"동기 vs 비동기","blocking-vs-nonblocking":"블로킹 vs 논 블로킹","completable-future":"CompletableFuture","completable-stage":"CompletableStage"}}]},{kind:"MdxPage",name:"index",route:"/"},{kind:"Folder",name:"nio-and-aio",route:"/nio-and-aio",children:[{kind:"MdxPage",name:"intro",route:"/nio-and-aio/intro"},{kind:"MdxPage",name:"java-io-java-nio-java-aio",route:"/nio-and-aio/java-io-java-nio-java-aio"},{kind:"MdxPage",name:"java-nio-socket-communication",route:"/nio-and-aio/java-nio-socket-communication"},{kind:"MdxPage",name:"what-is-aio",route:"/nio-and-aio/what-is-aio"},{kind:"MdxPage",name:"what-is-nio",route:"/nio-and-aio/what-is-nio"},{kind:"Meta",data:{intro:"Intro","java-io-java-nio-java-aio":"Java IO,NIO,AIO","what-is-nio":"NIO 의 개념, 특징, 주요 클래스","java-nio-socket-communication":"Java NIO 소켓통신","what-is-aio":"AIO 의 개념, 특징, 예제"}}]},{kind:"Folder",name:"r2dbc-mysql",route:"/r2dbc-mysql",children:[{kind:"MdxPage",name:"example",route:"/r2dbc-mysql/example"},{kind:"MdxPage",name:"intro",route:"/r2dbc-mysql/intro"},{kind:"MdxPage",name:"what-is-r2dbc",route:"/r2dbc-mysql/what-is-r2dbc"},{kind:"Meta",data:{intro:"Intro","what-is-r2dbc":"R2DBC 란?",example:"예제"}}]},{kind:"Folder",name:"reactive-mongodb",route:"/reactive-mongodb",children:[{kind:"MdxPage",name:"example",route:"/reactive-mongodb/example"},{kind:"MdxPage",name:"intro",route:"/reactive-mongodb/intro"},{kind:"Meta",data:{intro:"Intro",example:"예제"}}]},{kind:"Folder",name:"reactive-programming",route:"/reactive-programming",children:[{kind:"MdxPage",name:"intro",route:"/reactive-programming/intro"},{kind:"MdxPage",name:"java-nio-bad-point-and-solution",route:"/reactive-programming/java-nio-bad-point-and-solution"},{kind:"MdxPage",name:"netflix-rxjava-story",route:"/reactive-programming/netflix-rxjava-story"},{kind:"MdxPage",name:"proactor-pattern",route:"/reactive-programming/proactor-pattern"},{kind:"MdxPage",name:"reactive-streams-libraries",route:"/reactive-programming/reactive-streams-libraries"},{kind:"MdxPage",name:"reactive-streams",route:"/reactive-programming/reactive-streams"},{kind:"MdxPage",name:"reactor-pattern",route:"/reactive-programming/reactor-pattern"},{kind:"MdxPage",name:"what-is-epoll",route:"/reactive-programming/what-is-epoll"},{kind:"MdxPage",name:"what-is-reactive",route:"/reactive-programming/what-is-reactive"},{kind:"Meta",data:{intro:"intro","what-is-reactive":"Reactive란?","netflix-rxjava-story":"Netflix RxJava 이야기","reactive-streams":"Reactive Streams - Publisher, Subscriber 개념, 예제","reactive-streams-libraries":"Reactive Streams 라이브러리들","java-nio-bad-point-and-solution":"Java NIO 의 논블로킹 방식 동기연산의 문제점과 해결책, 멀티플렉싱","what-is-epoll":"epoll 이란?","reactor-pattern":"reactor 패턴","proactor-pattern":"proactor 패턴"}}]},{kind:"Folder",name:"server-sent-event",route:"/server-sent-event",children:[{kind:"MdxPage",name:"example",route:"/server-sent-event/example"},{kind:"MdxPage",name:"intro",route:"/server-sent-event/intro"},{kind:"MdxPage",name:"what-is-sse",route:"/server-sent-event/what-is-sse"},{kind:"Meta",data:{intro:"Intro","what-is-sse":"SSE (Server Sent Event) 의 개념",example:"예제코드"}}]},{kind:"Folder",name:"spring-cloud-stream-and-kafka",route:"/spring-cloud-stream-and-kafka",children:[{kind:"MdxPage",name:"intro",route:"/spring-cloud-stream-and-kafka/intro"},{kind:"MdxPage",name:"kafka-basic",route:"/spring-cloud-stream-and-kafka/kafka-basic"},{kind:"MdxPage",name:"kafka-docker-compose",route:"/spring-cloud-stream-and-kafka/kafka-docker-compose"},{kind:"MdxPage",name:"spring-cloud-stream-kafka-binder",route:"/spring-cloud-stream-and-kafka/spring-cloud-stream-kafka-binder"},{kind:"MdxPage",name:"spring-cloud-stream",route:"/spring-cloud-stream-and-kafka/spring-cloud-stream"},{kind:"Meta",data:{intro:"Intro","kafka-basic":"Kafka 의 주요 개념들","kafka-docker-compose":"Kafak 로컬 개발환경 (docker-compose)","spring-cloud-stream":"Spring Cloud Stream","spring-cloud-stream-kafka-binder":"Spring Cloud Stream Kafka Binder"}}]},{kind:"Folder",name:"spring-webflux",route:"/spring-webflux",children:[{kind:"MdxPage",name:"annotated-controller",route:"/spring-webflux/annotated-controller"},{kind:"MdxPage",name:"codec",route:"/spring-webflux/codec"},{kind:"MdxPage",name:"dispatcher-handler-communication-spring-webflux",route:"/spring-webflux/dispatcher-handler-communication-spring-webflux"},{kind:"MdxPage",name:"intro",route:"/spring-webflux/intro"},{kind:"MdxPage",name:"servlet-stack-vs-reactive-stack",route:"/spring-webflux/servlet-stack-vs-reactive-stack"},{kind:"MdxPage",name:"spring-mvc-vs-spring-webflux",route:"/spring-webflux/spring-mvc-vs-spring-webflux"},{kind:"Meta",data:{intro:"Intro","servlet-stack-vs-reactive-stack":"Servlet Stack vs Reactive Stack","spring-mvc-vs-spring-webflux":"Spring MVC vs Spring Webflux","dispatcher-handler-communication-spring-webflux":"DispatcherHandler 와 Spring Webflux","annotated-controller":"Annotated Controller",codec:"Codec"}}]},{kind:"Folder",name:"webflux-websocket",route:"/webflux-websocket",children:[{kind:"MdxPage",name:"example",route:"/webflux-websocket/example"},{kind:"MdxPage",name:"intro",route:"/webflux-websocket/intro"},{kind:"Meta",data:{intro:"Intro",example:"예제"}}]},{kind:"Meta",data:{index:"Introduction","concurrent-programming-basic":"동시성 프로그래밍 개념들","nio-and-aio":"NIO, AIO","reactive-programming":"Reactive Programming","spring-webflux":"Spring Webflux","server-sent-event":"Server Sent Event (SSE)","webflux-websocket":"Webflux Websocket","r2dbc-mysql":"Spring Data R2dbc","reactive-mongodb":"Spring Data Reactive Mongodb","spring-cloud-stream-and-kafka":"Spring Cloud Stream & Kafka",contact:{title:"Contact ↗",type:"page",href:"-",newWindow:!0}}}],flexsearch:{codeblocks:!0},title:"Java Nio Bad Point and Solution",headings:l},pageNextRoute:"/reactive-programming/java-nio-bad-point-and-solution",nextraLayout:t.ZP,themeConfig:o.Z};var m=(0,i.j)(g)},8426:function(e,a,n){"use strict";var r=n(5893);n(7294);let i={logo:(0,r.jsx)("span",{children:"Docs Spring Webflux"}),project:{link:"https://github.com/chagchagchag/docs-spring-webflux"},docsRepositoryBase:"https://github.com/chagchagchag/docs-spring-webflux",footer:{text:"Nextra Docs Template"}};a.Z=i},5789:function(){}},function(e){e.O(0,[774,796,888,179],function(){return e(e.s=7164)}),_N_E=e.O()}]);