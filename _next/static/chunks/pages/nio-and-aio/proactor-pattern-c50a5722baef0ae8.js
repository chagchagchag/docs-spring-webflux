(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2938],{6503:function(e,a,r){(window.__NEXT_P=window.__NEXT_P||[]).push(["/nio-and-aio/proactor-pattern",function(){return r(317)}])},317:function(e,a,r){"use strict";r.r(a),r.d(a,{__toc:function(){return s}});var n=r(5893),t=r(2673),i=r(373),o=r(8426);r(9128);var c=r(2643);let s=[{depth:2,value:"Proactor 패턴",id:"proactor-패턴"},{depth:2,value:"call flow",id:"call-flow"},{depth:2,value:"e.g.",id:"eg"}];function _createMdxContent(e){let a=Object.assign({h2:"h2",p:"p",ul:"ul",li:"li"},(0,c.a)(),e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.h2,{id:"proactor-패턴",children:"Proactor 패턴"}),"\n",(0,n.jsx)(a.p,{children:"Proactor 패턴에서는 아래의 세가지만 기억하시면, 오랫동안 기억에 남습니다."}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsx)(a.li,{children:"CompletionHandler"}),"\n",(0,n.jsx)(a.li,{children:"callback"}),"\n",(0,n.jsx)(a.li,{children:"커널에  직접 접근"}),"\n"]}),"\n",(0,n.jsx)("br",{}),"\n",(0,n.jsxs)(a.p,{children:["Proactor 패턴의 소켓프로그래밍에서는 callback 방식의 네트워크 핸들링 처리를 합니다. 그리고 Callback 은 보통 CompletionHandler 를 implements 한 구체타입을 통해 구현합니다.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(a.p,{children:"Reactor 패턴에서는 사실 아래와 같은 문제점이 있었습니다."}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsx)(a.li,{children:"Reactor 패턴에서는 싱글스레드 기반으로 Selector 에 접근해서 이벤트를 처리하기에 꽤 높은 빈도의 트래픽이 발생할 경우, 이벤트 한 건의 처리가 오래 걸릴 경우와 같은 상황에서 시스템에 부하가 크게 발생하며 병목구간이 발생하게 됩니다. 싱글스레드 기반으로 Selector 를 운영하기에 부하가 생기게 됩니다."}),"\n",(0,n.jsx)(a.li,{children:"Reactor 패턴에서는 Selector 가 커널에 이벤트를 등록하고 인출하고 이벤트가 완료되었는지 확인합니다. 따라서 Selector 가 특정 이벤트 처리시에 병목구간이 생길 경우 대응 방안이 없습니다."}),"\n",(0,n.jsx)(a.li,{children:"즉 Reactor 패턴에서는 Selector 를 통해서 커널에 접근해야 하는데, Selector 가 병목이 생길 확률이 높습니다."}),"\n"]}),"\n",(0,n.jsx)("br",{}),"\n",(0,n.jsxs)(a.p,{children:["Proactor Pattern 은 이런 문제를 커널에 직접 커널에 등록하고, 이벤트 인출,완료 등을 수행하는 방식으로 해결합니다. Selector 의 이벤트 처리시 병목구간 발생에 대한 리스크가 없습니다.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(a.p,{children:["Proactor Pattern 은 callback, future 방식을 지원하는데, callback 방식을 통해 구현할 경우 CompletionHandler 인터페이스를 이용해서 구현 가능합니다.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(a.p,{children:["future 를 사용하는 예제, callback 을 사용하는 예제 모두 AIO 소켓 프로그래밍 예제에서 정리하고 개념 역시 한번 더 정리합니다. ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(a.p,{children:["이번 문서에서는 callback 을 사용하는 간단한 예제와, 동작의 흐름을 간단하게 정리하고 요약하고 넘어갑니다.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)(a.h2,{id:"call-flow",children:"call flow"}),"\n",(0,n.jsx)(a.h2,{id:"eg",children:"e.g."})]})}let d={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:a}=Object.assign({},(0,c.a)(),e.components);return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(_createMdxContent,{...e})}):_createMdxContent(e)},pageOpts:{filePath:"pages/nio-and-aio/proactor-pattern.mdx",route:"/nio-and-aio/proactor-pattern",timestamp:1713369953e3,pageMap:[{kind:"Folder",name:"concurrent-programming-basic",route:"/concurrent-programming-basic",children:[{kind:"MdxPage",name:"blocking-vs-nonblocking",route:"/concurrent-programming-basic/blocking-vs-nonblocking"},{kind:"MdxPage",name:"completable-future-completion-stage",route:"/concurrent-programming-basic/completable-future-completion-stage"},{kind:"MdxPage",name:"executor-service",route:"/concurrent-programming-basic/executor-service"},{kind:"MdxPage",name:"sync-vs-async",route:"/concurrent-programming-basic/sync-vs-async"},{kind:"Meta",data:{"sync-vs-async":"동기 vs 비동기","blocking-vs-nonblocking":"블로킹 vs 논 블로킹","executor-service":"ExecutorService","completable-future-completion-stage":"CompletableFuture, CompletableStage"}}]},{kind:"MdxPage",name:"concurrent-programming-basic",route:"/concurrent-programming-basic"},{kind:"MdxPage",name:"index",route:"/"},{kind:"Folder",name:"kotlin-coroutine",route:"/kotlin-coroutine",children:[{kind:"Meta",data:{}}]},{kind:"MdxPage",name:"kotlin-coroutine",route:"/kotlin-coroutine"},{kind:"MdxPage",name:"netty",route:"/netty"},{kind:"Folder",name:"nio-and-aio",route:"/nio-and-aio",children:[{kind:"MdxPage",name:"java-io-java-nio-java-aio",route:"/nio-and-aio/java-io-java-nio-java-aio"},{kind:"MdxPage",name:"java-nio-socket-communication",route:"/nio-and-aio/java-nio-socket-communication"},{kind:"MdxPage",name:"proactor-pattern",route:"/nio-and-aio/proactor-pattern"},{kind:"MdxPage",name:"reactor-pattern-based-http-server",route:"/nio-and-aio/reactor-pattern-based-http-server"},{kind:"MdxPage",name:"reactor-pattern-socket-communication",route:"/nio-and-aio/reactor-pattern-socket-communication"},{kind:"MdxPage",name:"reactor-pattern",route:"/nio-and-aio/reactor-pattern"},{kind:"MdxPage",name:"what-is-aio",route:"/nio-and-aio/what-is-aio"},{kind:"MdxPage",name:"what-is-nio",route:"/nio-and-aio/what-is-nio"},{kind:"Meta",data:{"java-io-java-nio-java-aio":"Java IO,NIO,AIO","what-is-nio":"NIO 의 개념, 특징, 주요 클래스","java-nio-socket-communication":"Java NIO 소켓통신","reactor-pattern":"Reactor 패턴","reactor-pattern-socket-communication":"Reactor 패턴 소켓통신, 예제","reactor-pattern-based-http-server":"Reactor 패턴 기반의 HTTP 서버 예제","proactor-pattern":"proactor 패턴","what-is-aio":"AIO 의 개념, 특징, 예제"}}]},{kind:"MdxPage",name:"nio-and-aio",route:"/nio-and-aio"},{kind:"Folder",name:"reactive-programming",route:"/reactive-programming",children:[{kind:"MdxPage",name:"java-nio-bad-point-and-solution",route:"/reactive-programming/java-nio-bad-point-and-solution"},{kind:"MdxPage",name:"netflix-rxjava-story",route:"/reactive-programming/netflix-rxjava-story"},{kind:"MdxPage",name:"publisher-subscriber-subscription-backpressure",route:"/reactive-programming/publisher-subscriber-subscription-backpressure"},{kind:"MdxPage",name:"reactive-streams-libraries",route:"/reactive-programming/reactive-streams-libraries"},{kind:"MdxPage",name:"webflux-backpressure-handling",route:"/reactive-programming/webflux-backpressure-handling"},{kind:"MdxPage",name:"what-is-epoll",route:"/reactive-programming/what-is-epoll"},{kind:"MdxPage",name:"what-is-reactive",route:"/reactive-programming/what-is-reactive"},{kind:"Meta",data:{"what-is-reactive":"Reactive란?","netflix-rxjava-story":"Netflix RxJava 이야기","publisher-subscriber-subscription-backpressure":"Publisher,Subscriber,Subscription,Backpressure","reactive-streams-libraries":"Reactive Streams 라이브러리들","webflux-backpressure-handling":"Spring Webflux 에서 Backpressure 핸들링","java-nio-bad-point-and-solution":"Java NIO 의 논블로킹 방식 동기연산의 문제점과 해결책, 멀티플렉싱","what-is-epoll":"epoll 이란?"}}]},{kind:"MdxPage",name:"reactive-programming",route:"/reactive-programming"},{kind:"MdxPage",name:"reactor",route:"/reactor"},{kind:"Folder",name:"server-sent-event",route:"/server-sent-event",children:[{kind:"MdxPage",name:"what-is-sse",route:"/server-sent-event/what-is-sse"},{kind:"Meta",data:{"what-is-sse":"SSE (Server Sent Event) 개념, Spring Webflux, 예제"}}]},{kind:"MdxPage",name:"server-sent-event",route:"/server-sent-event"},{kind:"Folder",name:"spring-cloud-reactive-circuitbreaker",route:"/spring-cloud-reactive-circuitbreaker",children:[{kind:"MdxPage",name:"reactive-circuit-breaker-basic",route:"/spring-cloud-reactive-circuitbreaker/reactive-circuit-breaker-basic"},{kind:"Meta",data:{"reactive-circuit-breaker-basic":"Reactive Cricuit Breaker"}}]},{kind:"MdxPage",name:"spring-cloud-reactive-circuitbreaker",route:"/spring-cloud-reactive-circuitbreaker"},{kind:"Folder",name:"spring-cloud-stream-and-kafka",route:"/spring-cloud-stream-and-kafka",children:[{kind:"MdxPage",name:"kafka-basic",route:"/spring-cloud-stream-and-kafka/kafka-basic"},{kind:"MdxPage",name:"kafka-docker-compose",route:"/spring-cloud-stream-and-kafka/kafka-docker-compose"},{kind:"MdxPage",name:"spring-cloud-stream-kafka-binder",route:"/spring-cloud-stream-and-kafka/spring-cloud-stream-kafka-binder"},{kind:"MdxPage",name:"spring-cloud-stream",route:"/spring-cloud-stream-and-kafka/spring-cloud-stream"},{kind:"Meta",data:{"kafka-basic":"Kafka 의 주요 개념들","kafka-docker-compose":"Kafak 로컬 개발환경 (docker-compose)","spring-cloud-stream":"Spring Cloud Stream","spring-cloud-stream-kafka-binder":"Spring Cloud Stream Kafka Binder"}}]},{kind:"MdxPage",name:"spring-cloud-stream-and-kafka",route:"/spring-cloud-stream-and-kafka"},{kind:"MdxPage",name:"spring-data-reactive",route:"/spring-data-reactive"},{kind:"Folder",name:"spring-webflux",route:"/spring-webflux",children:[{kind:"MdxPage",name:"annotated-controller",route:"/spring-webflux/annotated-controller"},{kind:"MdxPage",name:"codec",route:"/spring-webflux/codec"},{kind:"MdxPage",name:"dispatcher-handler-communication-spring-webflux",route:"/spring-webflux/dispatcher-handler-communication-spring-webflux"},{kind:"MdxPage",name:"reactor-programming-all-2",route:"/spring-webflux/reactor-programming-all-2"},{kind:"MdxPage",name:"reactor-programming-all-3",route:"/spring-webflux/reactor-programming-all-3"},{kind:"MdxPage",name:"reactor-programming-all",route:"/spring-webflux/reactor-programming-all"},{kind:"MdxPage",name:"servlet-stack-vs-reactive-stack",route:"/spring-webflux/servlet-stack-vs-reactive-stack"},{kind:"MdxPage",name:"spring-mvc-vs-spring-webflux",route:"/spring-webflux/spring-mvc-vs-spring-webflux"},{kind:"Meta",data:{"servlet-stack-vs-reactive-stack":"Servlet Stack vs Reactive Stack","spring-mvc-vs-spring-webflux":"Spring MVC vs Spring Webflux","dispatcher-handler-communication-spring-webflux":"DispatcherHandler 와 Spring Webflux","annotated-controller":"Annotated Controller",codec:"Codec","reactor-programming-all":"Reactor 프로그래밍 (스압 주의)","reactor-programming-all-2":"Reactor 프로그래밍 2 (Thread, Scheduler, defer())","reactor-programming-all-3":"Reactor 프로그래밍 3 (Error 핸들링)"}}]},{kind:"MdxPage",name:"spring-webflux",route:"/spring-webflux"},{kind:"Folder",name:"webflux-websocket",route:"/webflux-websocket",children:[{kind:"MdxPage",name:"what-is-websocket",route:"/webflux-websocket/what-is-websocket"},{kind:"Meta",data:{"what-is-websocket":"Websocket 개념, Spring Webflux, 예제"}}]},{kind:"MdxPage",name:"webflux-websocket",route:"/webflux-websocket"},{kind:"Meta",data:{index:"Introduction","concurrent-programming-basic":"동시성 프로그래밍 개념들","nio-and-aio":"NIO, AIO",netty:"Netty",reactor:"Reactor","reactive-programming":"Reactive Programming","spring-webflux":"Spring Webflux","spring-cloud-stream-and-kafka":"Spring Cloud Stream & Kafka","spring-cloud-reactive-circuitbreaker":"Spring Cloud Reactive Circuit Breaker","kotlin-coroutine":"Kotlin Coroutine","server-sent-event":"Server Sent Event (SSE)","webflux-websocket":"Webflux Websocket","spring-data-reactive":"Spring Data Reactive",contact:{title:"Contact ↗",type:"page",href:"-",newWindow:!0}}}],flexsearch:{codeblocks:!0},title:"Proactor Pattern",headings:s},pageNextRoute:"/nio-and-aio/proactor-pattern",nextraLayout:i.ZP,themeConfig:o.Z};a.default=(0,t.j)(d)},8426:function(e,a,r){"use strict";var n=r(5893);r(7294);let t={logo:(0,n.jsx)("span",{children:"Docs Spring Webflux"}),project:{link:"https://github.com/chagchagchag/docs-spring-webflux"},docsRepositoryBase:"https://github.com/chagchagchag/docs-spring-webflux",footer:{text:"Nextra Docs Template"}};a.Z=t},5789:function(){}},function(e){e.O(0,[9774,6796,2888,179],function(){return e(e.s=6503)}),_N_E=e.O()}]);