(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[8837],{8682:function(e,r,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/server-sent-event/what-is-sse",function(){return n(9802)}])},9802:function(e,r,n){"use strict";n.r(r),n.d(r,{__toc:function(){return m},default:function(){return v}});var i=n(5893),a=n(2673),t=n(373),s=n(8426);n(9128);var l=n(2643),o={src:"/docs-spring-webflux/_next/static/media/polling.a9779e52.png",height:557,width:389,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAICAMAAADtGH4KAAAAQlBMVEX////+/v77+/v6+vr5+fn4+Pj39/f29vb19fX09PTz8/Py8vLy8fHx8fHw8PDv7+/u7u7r6+uysa+gn5yMi4WAfncq1d+wAAAAN0lEQVR42hXISQKAIAwDwDSohah1Af7/VeA4A7/yfgt//45Wsb2hSFCcRUQJuaYercxulggjQA44LgGitJiF6wAAAABJRU5ErkJggg==",blurWidth:6,blurHeight:8},d={src:"/docs-spring-webflux/_next/static/media/long-polling.ba048242.png",height:558,width:381,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAICAMAAAAGL8UJAAAAOVBMVEX////9/f38/Pz7+/v6+vr5+fn4+Pj39/f29vf29vb09PTz8/Py8vLx8fHv7++sq6mop6SXlpKVlJAPqtoSAAAALklEQVR42gWAhw3AIAzA3CxK2Px/LCJ7GcndrEO0On+kZig+Sg/U3RQLxJAP0QciFAEce8GIiwAAAABJRU5ErkJggg==",blurWidth:5,blurHeight:8},c={src:"/docs-spring-webflux/_next/static/media/http-streaming.196a945d.png",height:557,width:381,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAICAMAAAAGL8UJAAAAOVBMVEX////9/f38/Pz7+/v6+vr5+fn4+Pj39/f19fX09PTz8/Py8vLx8fHv7+/v7+6sq6ipqaaYl5OXlpGxSmcVAAAAMUlEQVR42g3ExwEAIQgAwQUDKHem/ovVeQweNjp7MQ8W/htSW8/kr/k7qiqlIEpSJF0hOAEV6bRyHgAAAABJRU5ErkJggg==",blurWidth:5,blurHeight:8},p={src:"/docs-spring-webflux/_next/static/media/server-sent-event-flow.7e9cc9b0.png",height:1158,width:705,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAICAAAAAAUmmrnAAAAL0lEQVR42hXGwQ0AIAgDwO4/qj8TI1SkKJ/LIUMlxMnv3n231kwqkOEXIlOoNaYesIwnNWrP0DgAAAAASUVORK5CYII=",blurWidth:5,blurHeight:8},g={src:"/docs-spring-webflux/_next/static/media/handler-result-handler-impl.4722835c.png",height:435,width:910,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAECAAAAACWpiEsAAAAKElEQVR42g3EwREAIAwCMPafty1Qz0PzCJKMfrB2aBmijjnC7equ2gczLh8d3vomuwAAAABJRU5ErkJggg==",blurWidth:8,blurHeight:4},h={src:"/docs-spring-webflux/_next/static/media/handler-result-handler-wirte-flow.b88875f0.png",height:1096,width:1598,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAFCAIAAAD38zoCAAAAbklEQVR42mP4////379/f/78+f379/9IgOHZ02dPnjx9+uzZ58+fd+3aNn/+nIULFy1esoTBzt5QR1+cgYHh0KHD7R2tDHDw6tVzIHr69MmXL1/r62uBIhJSkvr6hgz/kcCSJQta26ra2xtaW1sAXrJPQj/7pGAAAAAASUVORK5CYII=",blurWidth:8,blurHeight:5},u={src:"/docs-spring-webflux/_next/static/media/server-sent-event-http-message-writer.d4bc874c.png",height:311,width:1868,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAABCAIAAABsYngUAAAAIUlEQVR42mMwU1cyNjQx1Dc3MjA1MLHQ0dXX0NBRUdUEADflBFjastJ/AAAAAElFTkSuQmCC",blurWidth:8,blurHeight:1},x={src:"/docs-spring-webflux/_next/static/media/write.e7fc059e.png",height:427,width:1460,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAACCAIAAADq9gq6AAAAN0lEQVR42g3CSQ4AEAwAQI9xoIpYuiXl/89iMoGFxXyTLfFJhhVLqQAjzKVkl/T82EaClnKPMT/zBQleZDHEXQAAAABJRU5ErkJggg==",blurWidth:8,blurHeight:2};let m=[{depth:2,value:"Server Sent Event",id:"server-sent-event"},{depth:2,value:"참고자료",id:"참고자료"},{depth:2,value:"Polling, Long Polling, HTTP Streaming",id:"polling-long-polling-http-streaming"},{depth:3,value:"Polling",id:"polling"},{depth:3,value:"Long Polling",id:"long-polling"},{depth:3,value:"HTTP Streaming",id:"http-streaming"},{depth:2,value:"Server Sent Event",id:"server-sent-event-1"},{depth:2,value:"데이터 형식",id:"데이터-형식"},{depth:2,value:"Spring 내에서의 상호작용",id:"spring-내에서의-상호작용"},{depth:3,value:"DispatcherHandler 의 요청 처리",id:"dispatcherhandler-의-요청-처리"},{depth:3,value:"HandlerResultHandler 가 ResponseBody 를 처리하는 과정",id:"handlerresulthandler-가-responsebody-를-처리하는-과정"},{depth:2,value:"e.g.",id:"eg"}];function _createMdxContent(e){let r=Object.assign({h2:"h2",ul:"ul",li:"li",a:"a",h3:"h3",p:"p",img:"img",pre:"pre",code:"code",span:"span",blockquote:"blockquote",strong:"strong"},(0,l.a)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.h2,{id:"server-sent-event",children:"Server Sent Event"}),"\n",(0,i.jsx)(r.h2,{id:"참고자료",children:"참고자료"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events",children:"Using Server Sent events (MDN)"})}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/HandlerResultHandler.html",children:"HandlerResultHandler"}),", ",(0,i.jsx)(r.a,{href:"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.html",children:"ResponseBodyResultHandler"}),", ",(0,i.jsx)(r.a,{href:"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandler.html",children:"ResponseEntityResultHandler"}),", ",(0,i.jsx)(r.a,{href:"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/result/view/ViewResolutionResultHandler.html",children:"ViewResolutionResultHandler"}),", ",(0,i.jsx)(r.a,{href:"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/server/support/ServerResponseResultHandler.html",children:"ServerResponseResultHandler"})]}),"\n",(0,i.jsx)(r.li,{children:(0,i.jsx)(r.a,{href:"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/codec/ServerSentEventHttpMessageWriter.html",children:"ServerSentEventHttpMessageWriter"})}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(r.h2,{id:"polling-long-polling-http-streaming",children:"Polling, Long Polling, HTTP Streaming"}),"\n",(0,i.jsx)(r.h3,{id:"polling",children:"Polling"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{placeholder:"blur",src:o})}),"\n",(0,i.jsxs)(r.p,{children:["서버는 요청을 기다리고 있다가 요청이 왔을 때 응답을 해주는 역할만을 수행합니다. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.p,{children:["클라이언트는 일정 간격마다 한번 씩 Request 를 합니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.p,{children:["클라이언트가 짧은 주기마다 서버에 요청을 요청하면 서버에 부담이 가고, 서버에 요청을 하는 주기를 길게 잡으면 실시간성이 떨어집니다. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(r.h3,{id:"long-polling",children:"Long Polling"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{placeholder:"blur",src:d})}),"\n",(0,i.jsxs)(r.p,{children:["클라이언트는 서버에 request 를 합니다. 서버는 미리 지정한 timeout 기간 마다 timeout 기간 내에 데이터 또는 이벤트를 클라이언트에 전달합니다. 서버는 데이터가 준비되지 않았거나 이벤트가 없더라도 timeout 이 지났다면 데이터가 없다거나 이벤트가 없다는 내용을 response 로 전달해줍니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.p,{children:["클라이언트는 응답을 받은 후 대기 없이 바로 다시 request 를 합니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.p,{children:["만약 클라이언트에게 제공할 데이터/이벤트가 여러개일 경우 각각의 데이터/이벤트를 단건으로 여러개의 long poll 요청에 나눠서 전달해줍니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.p,{children:["구현의 난이도가 낮으며, 이벤트, 데이터가 있을 때마다 데이터를 돌려주는 방식이기에 Polling 방식보다는 실시간성이 조금은 높습니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.p,{children:["하지만 서버 측에서는 TCP/IP 연결을 오랫동안 열어둔 상태로 대기해야 한다는 점, Connection Pool 관리 문제가 있고 클라이언트 측에서는 브라우저, gateway 등의 timeout 을 고려해서 서버의 long poll 대기 시간을 정해야 하기에 운영환경에 따라 재배포 이슈가 생기게 됩니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(r.h3,{id:"http-streaming",children:"HTTP Streaming"}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{placeholder:"blur",src:c})}),"\n",(0,i.jsxs)(r.p,{children:["클라이언트는 최초 1회 Server 에 요청을 보냅니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.p,{children:["서버는 전달할 데이터가 있거나 이벤트가 있을 때마다 응답을 전달해줍니다. 클라이언트의 request 는 닫지 않고 계속해서 이벤트, 데이터가 생길때마다 클라이언트 측에 전달해줍니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.p,{children:["서버 입장에서는 응답을 내려 줄 때 Content-Length 를 내려주기 곤란한 경우가 있습니다. 예를 들면 컨텐츠의 길이를 알 수 없이 계속 해서 생기는 경우가 있기도 하고 길이 자체를 미리 알 수 없는 경우입니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(r.p,{children:"이런 경우 HTTP Streaming 을 아래와 같이 구현합니다."}),"\n",(0,i.jsx)(r.p,{children:"Transfer-Encoding 헤더"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Transfer-Encoding: chunked 를 헤더에 추가해서 chunk 단위로 데이터를 나눠서 보냄을 명시합니다."}),"\n",(0,i.jsxs)(r.li,{children:["클라이언트는 비어있는 chunk 를 전달받기 전까지는 계속해서 값을 읽음","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"예를 들어 개행문자가 두번 이어질 경우 데이터의 끝임을 클라이언트 측에서 인지합니다."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.li,{children:"HTTP/1.1 이상에서만 사용가능합니다."}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"EOF"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"서버의 연결 종료를 양방향 간에 파악하는 방법입니다."}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"Connection: close 를 헤더에 추가합니다."}),"\n"]}),"\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsx)(r.p,{children:"서버가 연결을 종료하겠다는 메시지를 보내기 전까지는 들어오는 값을 읽습니다."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(r.h2,{id:"server-sent-event-1",children:"Server Sent Event"}),"\n",(0,i.jsx)(r.h2,{id:"데이터-형식",children:"데이터 형식"}),"\n",(0,i.jsxs)(r.p,{children:["참고 : ",(0,i.jsx)(r.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#fields",children:"Using Server Sent events (MDN)"})]}),"\n",(0,i.jsx)(r.pre,{"data-language":"plain","data-theme":"default",children:(0,i.jsxs)(r.code,{"data-language":"plain","data-theme":"default",children:[(0,i.jsx)(r.span,{className:"line",children:(0,i.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"id:0 "})}),"\n",(0,i.jsx)(r.span,{className:"line",children:(0,i.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"event:vote "})}),"\n",(0,i.jsx)(r.span,{className:"line",children:(0,i.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:":election-event-k"})}),"\n",(0,i.jsx)(r.span,{className:"line",children:(0,i.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"data:김철수"})}),"\n",(0,i.jsx)(r.span,{className:"line",children:(0,i.jsx)(r.span,{style:{color:"var(--shiki-color-text)"}})}),"\n",(0,i.jsx)(r.span,{className:"line",children:(0,i.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"id:1 "})}),"\n",(0,i.jsx)(r.span,{className:"line",children:(0,i.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"event:vote "})}),"\n",(0,i.jsx)(r.span,{className:"line",children:(0,i.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:":election-event-k"})}),"\n",(0,i.jsx)(r.span,{className:"line",children:(0,i.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"data:고영희"})}),"\n",(0,i.jsx)(r.span,{className:"line",children:(0,i.jsx)(r.span,{style:{color:"var(--shiki-color-text)"}})})]})}),"\n",(0,i.jsx)(r.p,{children:"id"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["클라이언트에서는 이벤트의 id 를 저장하고 있고 연결이 끊기거나 재접속을 할 때 ",(0,i.jsx)(r.code,{children:"Last-Event-ID"})," 헤더에 이벤트의 id 를 첨부해서 가장 마지막으로 받은 이벤트가 무엇인지 전달합니다."]}),"\n",(0,i.jsx)(r.li,{children:"이렇게 하면 서버는 lastEventId 보다 큰 이벤트만 전달 가능함을 보장할 수 있습니다."}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"event"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"이벤트의 타입을 표현하는 데에 사용됩니다."}),"\n",(0,i.jsxs)(r.li,{children:["정해진 것은 없고 위의 예제에서는 투표하는 경우를 예로 들어서 ",(0,i.jsx)(r.code,{children:"vote"})," 로 지정해주었습니다."]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"data"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"이벤트가 가진 data 를 표현합니다."}),"\n",(0,i.jsx)(r.li,{children:"만약 data 가 여러 줄로 표현되는 경우 new line (개행문자)로 구분해서 표현합니다."}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"retry"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"재접속(reconnection)을 위한 대기시간을 클라이언트에 전달할 때 사용하는 필드입니다."}),"\n",(0,i.jsx)(r.li,{children:"밀리세컨드로 표현됩니다."}),"\n",(0,i.jsx)(r.li,{children:"만약 문제가 생겨서 연결이 유실되면 retry 에 명시한 대기시간 만큼 대기한 후 재접속을 요청합니다."}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"comment"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["위에서는 ",(0,i.jsx)(r.code,{children:":election-event-k"})," 라고 표현된 필드입니다."]}),"\n",(0,i.jsx)(r.li,{children:"단순히 정보를 남기기 위해서 사용하는 필드입니다."}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(r.h2,{id:"spring-내에서의-상호작용",children:"Spring 내에서의 상호작용"}),"\n",(0,i.jsx)(r.h3,{id:"dispatcherhandler-의-요청-처리",children:"DispatcherHandler 의 요청 처리"}),"\n",(0,i.jsx)(r.p,{children:"일반적으로 잘 알려진 RequestMapping → HandlerMapping → HandlerMappingAdapter → ResultHandler(ResponseBodyResultHandler)의 순서를 따릅니다."}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{placeholder:"blur",src:p})}),"\n",(0,i.jsx)(r.p,{children:"ServerWebExchange"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"request 는 ServerWebExchange 타입으로 변환됩니다."}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"DispatcherHandler"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"요청의 내용들을 기반으로 알맞은 HandlerMapping을 찾습니다"}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"HandlerMapping"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"DispatcherHandler 는 HandlerAdapter 를 이용해서 방금 찾은 HandlerMapping을 HandlerAdapter에 함께 넘겨 주어서 적절한 Controller 나 Functional Endpoint 를 찾습니다."}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"HandlerAdapter"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Controller 등에서 처리한 애플리케이션의 ",(0,i.jsx)(r.code,{children:"Flux<ServerSentEvent"})," 같은 처리 결과는 ",(0,i.jsx)(r.code,{children:"HandlerResult"})," 라는 타입 안에 담아서 HandlerResult를 ",(0,i.jsx)(r.code,{children:"HandlerResultHandler"})," 에 전달해줍니다."]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"HandlerResultHandler"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"byteBuffer 단위의 네트워킹 연산을 수행합니다."}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.a,{href:"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/HandlerResultHandler.html",children:"HandlerResultHandler"})," 는 interface 이며, 구체 타입으로는 아래와 같이 ",(0,i.jsx)(r.a,{href:"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.html",children:"ResponseBodyResultHandler"}),", ",(0,i.jsx)(r.a,{href:"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/result/method/annotation/ResponseEntityResultHandler.html",children:"ResponseEntityResultHandler"}),", ",(0,i.jsx)(r.a,{href:"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/result/view/ViewResolutionResultHandler.html",children:"ViewResolutionResultHandler"}),", ",(0,i.jsx)(r.a,{href:"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/server/support/ServerResponseResultHandler.html",children:"ServerResponseResultHandler"})," 등과 같이 여러 종류가 있습니다."]}),"\n",(0,i.jsxs)(r.li,{children:["만약 SSE 가 @ResponseBody 를 리턴할 경우 ",(0,i.jsx)(r.a,{href:"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/result/method/annotation/ResponseBodyResultHandler.html",children:"ResponseBodyResultHandler"}),"를 따르게 됩니다."]}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{placeholder:"blur",src:g})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(r.h3,{id:"handlerresulthandler-가-responsebody-를-처리하는-과정",children:"HandlerResultHandler 가 ResponseBody 를 처리하는 과정"}),"\n",(0,i.jsxs)(r.blockquote,{children:["\n",(0,i.jsxs)(r.p,{children:["내부 동작에 대한 설명입니다. 다소 필요없어보일 수도 있겠지만, 내부 동작을 보면서 원리를 파악하는 것도 좋겠다는 생각이 들어서 정리합니다.",(0,i.jsx)("br",{})]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:"위에서는 DispatcherHandler 에서 HandlerResultHandler 타입까지 어떻게 요청이 분류되는지를 살펴봤습니다. 이번에는 HandlerResultHandler 가 ServerSocketEvent 를 ResponseBody 로 처리하려 할 때 어떻게 내부 동작이 이뤄지는지를 살펴봅니다."}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{placeholder:"blur",src:h})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"ResponseBodyResultHandler::handleResult(...) → AbstractMessageWriterResultHandler::writeBody(...)"}),(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["ResponseBodyResultHandler 내에서 handleResult 의 요청을 처리한 후 제일 마지막으로 writeBody(...) 메서드를 호출하는데 이것은 AbstractMessageWriterResultHandler 내부의 writeBody(...)를 호출하게 됩니다.",(0,i.jsx)("br",{})]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"AbstractMessageWriterResultHandler::writeBody(...) → HttpMessageWriter::write(Publisher)"}),(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["writeBody() 메서드에서는 요청에 맞는 HttpMessageWriter 에 대한 구체타입을 for loop 을 순회하면서 찾고, 요청에 맞는 writer 를 찾았다면, 그 구체타입에 대한 HttpMessageWriter 객체의 write(Publisher) 메서드를 실행합니다.",(0,i.jsx)("br",{})]}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsxs)(r.p,{children:["그리고 HttpMessageWriter 타입의 객체 들 중 SSE 를 처리하는 타입은 ",(0,i.jsx)(r.a,{href:"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/codec/ServerSentEventHttpMessageWriter.html",children:"ServerSentEventHttpMessageWriter"})," 입니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(r.p,{children:["그리고 내부 구현중 일부를 보면 아래와 같이 ",(0,i.jsx)(r.code,{children:"WRITABLE_MEDIA_TYPES"})," 에 ",(0,i.jsx)(r.code,{children:"TEXT_EVENT_STREAM"})," 이 지정되어 있고, ",(0,i.jsx)(r.code,{children:"DEFAULT_MEDIA_TYPE"})," 은 text, event-stream 이라는 것을 확인 가능합니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{placeholder:"blur",src:u})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(r.p,{children:"그리고 실제 write 연산은 아래와 같이 ByteBufferFactory 를 이용해서 물리적인 전송 연산을 수행하고 있습니다."}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{placeholder:"blur",src:x})}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(r.h2,{id:"eg",children:"e.g."})]})}let A={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,l.a)(),e.components);return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(_createMdxContent,{...e})}):_createMdxContent(e)},pageOpts:{filePath:"pages/server-sent-event/what-is-sse.mdx",route:"/server-sent-event/what-is-sse",timestamp:1710992457e3,pageMap:[{kind:"Folder",name:"concurrent-programming-basic",route:"/concurrent-programming-basic",children:[{kind:"MdxPage",name:"blocking-vs-nonblocking",route:"/concurrent-programming-basic/blocking-vs-nonblocking"},{kind:"MdxPage",name:"completable-future",route:"/concurrent-programming-basic/completable-future"},{kind:"MdxPage",name:"completable-stage",route:"/concurrent-programming-basic/completable-stage"},{kind:"MdxPage",name:"intro",route:"/concurrent-programming-basic/intro"},{kind:"MdxPage",name:"sync-vs-async",route:"/concurrent-programming-basic/sync-vs-async"},{kind:"Meta",data:{intro:"Intro","sync-vs-async":"동기 vs 비동기","blocking-vs-nonblocking":"블로킹 vs 논 블로킹","completable-future":"CompletableFuture","completable-stage":"CompletableStage"}}]},{kind:"MdxPage",name:"index",route:"/"},{kind:"Folder",name:"kotlin-coroutine",route:"/kotlin-coroutine",children:[{kind:"MdxPage",name:"intro",route:"/kotlin-coroutine/intro"},{kind:"Meta",data:{intro:"Intro"}}]},{kind:"Folder",name:"nio-and-aio",route:"/nio-and-aio",children:[{kind:"MdxPage",name:"intro",route:"/nio-and-aio/intro"},{kind:"MdxPage",name:"java-io-java-nio-java-aio",route:"/nio-and-aio/java-io-java-nio-java-aio"},{kind:"MdxPage",name:"java-nio-socket-communication",route:"/nio-and-aio/java-nio-socket-communication"},{kind:"MdxPage",name:"what-is-aio",route:"/nio-and-aio/what-is-aio"},{kind:"MdxPage",name:"what-is-nio",route:"/nio-and-aio/what-is-nio"},{kind:"Meta",data:{intro:"Intro","java-io-java-nio-java-aio":"Java IO,NIO,AIO","what-is-nio":"NIO 의 개념, 특징, 주요 클래스","java-nio-socket-communication":"Java NIO 소켓통신","what-is-aio":"AIO 의 개념, 특징, 예제"}}]},{kind:"Folder",name:"r2dbc-mysql",route:"/r2dbc-mysql",children:[{kind:"MdxPage",name:"example",route:"/r2dbc-mysql/example"},{kind:"MdxPage",name:"intro",route:"/r2dbc-mysql/intro"},{kind:"MdxPage",name:"what-is-r2dbc",route:"/r2dbc-mysql/what-is-r2dbc"},{kind:"Meta",data:{intro:"Intro","what-is-r2dbc":"R2DBC 란?",example:"예제"}}]},{kind:"Folder",name:"reactive-mongodb",route:"/reactive-mongodb",children:[{kind:"MdxPage",name:"example",route:"/reactive-mongodb/example"},{kind:"MdxPage",name:"intro",route:"/reactive-mongodb/intro"},{kind:"Meta",data:{intro:"Intro",example:"예제"}}]},{kind:"Folder",name:"reactive-programming",route:"/reactive-programming",children:[{kind:"MdxPage",name:"intro",route:"/reactive-programming/intro"},{kind:"MdxPage",name:"java-nio-bad-point-and-solution",route:"/reactive-programming/java-nio-bad-point-and-solution"},{kind:"MdxPage",name:"netflix-rxjava-story",route:"/reactive-programming/netflix-rxjava-story"},{kind:"MdxPage",name:"proactor-pattern",route:"/reactive-programming/proactor-pattern"},{kind:"MdxPage",name:"publisher-subscriber-subscription-backpressure",route:"/reactive-programming/publisher-subscriber-subscription-backpressure"},{kind:"MdxPage",name:"reactive-streams-libraries",route:"/reactive-programming/reactive-streams-libraries"},{kind:"MdxPage",name:"reactor-pattern",route:"/reactive-programming/reactor-pattern"},{kind:"MdxPage",name:"webflux-backpressure-handling",route:"/reactive-programming/webflux-backpressure-handling"},{kind:"MdxPage",name:"what-is-epoll",route:"/reactive-programming/what-is-epoll"},{kind:"MdxPage",name:"what-is-reactive",route:"/reactive-programming/what-is-reactive"},{kind:"Meta",data:{intro:"intro","what-is-reactive":"Reactive란?","netflix-rxjava-story":"Netflix RxJava 이야기","publisher-subscriber-subscription-backpressure":"Publisher,Subscriber,Subscription,Backpressure","reactive-streams-libraries":"Reactive Streams 라이브러리들","webflux-backpressure-handling":"Spring Webflux 에서 Backpressure 핸들링","java-nio-bad-point-and-solution":"Java NIO 의 논블로킹 방식 동기연산의 문제점과 해결책, 멀티플렉싱","what-is-epoll":"epoll 이란?","reactor-pattern":"reactor 패턴","proactor-pattern":"proactor 패턴"}}]},{kind:"Folder",name:"server-sent-event",route:"/server-sent-event",children:[{kind:"MdxPage",name:"example",route:"/server-sent-event/example"},{kind:"MdxPage",name:"intro",route:"/server-sent-event/intro"},{kind:"MdxPage",name:"what-is-sse",route:"/server-sent-event/what-is-sse"},{kind:"Meta",data:{intro:"Intro","what-is-sse":"SSE (Server Sent Event) 의 개념",example:"예제코드"}}]},{kind:"Folder",name:"spring-cloud-reactive-circuitbreaker",route:"/spring-cloud-reactive-circuitbreaker",children:[{kind:"MdxPage",name:"intro",route:"/spring-cloud-reactive-circuitbreaker/intro"},{kind:"MdxPage",name:"reactive-circuit-breaker-basic",route:"/spring-cloud-reactive-circuitbreaker/reactive-circuit-breaker-basic"},{kind:"Meta",data:{intro:"Introduce","reactive-circuit-breaker-basic":"Reactive Cricuit Breaker"}}]},{kind:"Folder",name:"spring-cloud-stream-and-kafka",route:"/spring-cloud-stream-and-kafka",children:[{kind:"MdxPage",name:"intro",route:"/spring-cloud-stream-and-kafka/intro"},{kind:"MdxPage",name:"kafka-basic",route:"/spring-cloud-stream-and-kafka/kafka-basic"},{kind:"MdxPage",name:"kafka-docker-compose",route:"/spring-cloud-stream-and-kafka/kafka-docker-compose"},{kind:"MdxPage",name:"spring-cloud-stream-kafka-binder",route:"/spring-cloud-stream-and-kafka/spring-cloud-stream-kafka-binder"},{kind:"MdxPage",name:"spring-cloud-stream",route:"/spring-cloud-stream-and-kafka/spring-cloud-stream"},{kind:"Meta",data:{intro:"Intro","kafka-basic":"Kafka 의 주요 개념들","kafka-docker-compose":"Kafak 로컬 개발환경 (docker-compose)","spring-cloud-stream":"Spring Cloud Stream","spring-cloud-stream-kafka-binder":"Spring Cloud Stream Kafka Binder"}}]},{kind:"Folder",name:"spring-webflux",route:"/spring-webflux",children:[{kind:"MdxPage",name:"annotated-controller",route:"/spring-webflux/annotated-controller"},{kind:"MdxPage",name:"codec",route:"/spring-webflux/codec"},{kind:"MdxPage",name:"dispatcher-handler-communication-spring-webflux",route:"/spring-webflux/dispatcher-handler-communication-spring-webflux"},{kind:"MdxPage",name:"intro",route:"/spring-webflux/intro"},{kind:"MdxPage",name:"servlet-stack-vs-reactive-stack",route:"/spring-webflux/servlet-stack-vs-reactive-stack"},{kind:"MdxPage",name:"spring-mvc-vs-spring-webflux",route:"/spring-webflux/spring-mvc-vs-spring-webflux"},{kind:"Meta",data:{intro:"Intro","servlet-stack-vs-reactive-stack":"Servlet Stack vs Reactive Stack","spring-mvc-vs-spring-webflux":"Spring MVC vs Spring Webflux","dispatcher-handler-communication-spring-webflux":"DispatcherHandler 와 Spring Webflux","annotated-controller":"Annotated Controller",codec:"Codec"}}]},{kind:"Folder",name:"webflux-websocket",route:"/webflux-websocket",children:[{kind:"MdxPage",name:"example",route:"/webflux-websocket/example"},{kind:"MdxPage",name:"intro",route:"/webflux-websocket/intro"},{kind:"Meta",data:{intro:"Intro",example:"예제"}}]},{kind:"Meta",data:{index:"Introduction","concurrent-programming-basic":"동시성 프로그래밍 개념들","nio-and-aio":"NIO, AIO","reactive-programming":"Reactive Programming","spring-webflux":"Spring Webflux","spring-cloud-stream-and-kafka":"Spring Cloud Stream & Kafka","spring-cloud-reactive-circuitbreaker":"Spring Cloud Reactive Circuit Breaker","kotlin-coroutine":"Kotlin Coroutine","server-sent-event":"Server Sent Event (SSE)","webflux-websocket":"Webflux Websocket","r2dbc-mysql":"Spring Data R2dbc","reactive-mongodb":"Spring Data Reactive Mongodb",contact:{title:"Contact ↗",type:"page",href:"-",newWindow:!0}}}],flexsearch:{codeblocks:!0},title:"What Is Sse",headings:m},pageNextRoute:"/server-sent-event/what-is-sse",nextraLayout:t.ZP,themeConfig:s.Z};var v=(0,a.j)(A)},8426:function(e,r,n){"use strict";var i=n(5893);n(7294);let a={logo:(0,i.jsx)("span",{children:"Docs Spring Webflux"}),project:{link:"https://github.com/chagchagchag/docs-spring-webflux"},docsRepositoryBase:"https://github.com/chagchagchag/docs-spring-webflux",footer:{text:"Nextra Docs Template"}};r.Z=a},5789:function(){}},function(e){e.O(0,[9774,6796,2888,179],function(){return e(e.s=8682)}),_N_E=e.O()}]);