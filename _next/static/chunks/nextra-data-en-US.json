{"/":{"title":"Introduction","data":{"":"Webflux 및 동시성 프로그래밍, Reactive Programming 에 대해 정리하는 블로그입니다."}},"/concurrent-programming-basic/sync-vs-async":{"title":"Sync Vs Async","data":{"동기-vs-비동기#동기 vs 비동기":"오늘은 감기기운이 있어서 문서 작업을 시작하려 하는 데에 시간이 꽤 걸리기도 했고 분리수거 + 집안 청소를 하느라 거의 2시간 이상이 걸렸네요. 골골 거리면서 청소한다고 머리까지 아파서 라면을 엄청 맵고 짜게 끌여먹으면서 박카스를 마시니 그나마 나아지네요. 라면 + 박카스는 저의 민간요법 중 하나입니다....오늘 정리할 내용은 동기 vs 비동기 에 관련된 내용입니다. 너무 진지하게 심취하기보다는 비교적 쉽고 융통성 있게 개념을 정리하려 노력해보겠습니다.\r\n이걸 언제 정리하고 있나 하면서 멍때리다가 천리길도 한걸음부터라는 생각이 들면서 정리를 다시 시작하게 되었습니다","동기-synchronization#동기 (Synchronization)":"동기 라는 개념은 컴퓨터공학, 전자공학을 배우신 분들은 익숙하실 듯 합니다. 흔히 트랜지스터 별로 클록이 다르기에 서로 클록이 1이 되는 시점을 맞춰서 동기화 하는 그런 글들이 보신적이 있을 겁니다.컴퓨터공학, 전자공학이 아니더라도 일반인 분들 역시 드롭박스나 구글 드라이브에서 한동안 유행했던 동기화 버튼을 본적이 있을 것입니다.동기화라는 개념을 쉽게 설명하면 이렇습니다. 한쪽에서 다른 쪽의 결과값을 받아서 결과값을 맞추는 것을 동기화라고 합니다. 함수 관점에서 동기화는 caller 가 callee 의 결과값을 알기 위해 리턴값을 받는 동작을 의미합니다. 이때 callee 의 작업이 오래 걸리게 되어 기다리게 된다면 이렇게 기다리는 작업은 Blocking 이라고 부릅니다. 따라서 위의 예제는 블로킹 방식의 동기연산입니다.쉽게 이야기하면 아래와 같은 코드가 동기화를 수행하는 코드입니다.\npackage io.chagchagchag.example.foobar.concurrent.sync_async.simple;\r\n\r\nimport java.time.LocalTime;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\n@Slf4j\r\npublic class SimpleSyncExample {\r\n  public static void main(String [] args){\r\n    log.info(\"(start) main function \" + LocalTime.now());\r\n    var result = getLongDelayJob();\r\n    var increased = result + 1;\r\n    assert increased == 501;\r\n    log.info(\"(end) main function \" + LocalTime.now());\r\n  }\r\n\r\n  public static int getLongDelayJob(){\r\n    long current = System.currentTimeMillis();\r\n    while(true){\r\n      long timeSpent = System.currentTimeMillis() - current;\r\n      if(timeSpent > 1000) break;\r\n    }\r\n    return 500;\r\n  }\r\n}\n출력결과\n15:20:13.250 [main] INFO ...sync_async.simple.SimpleAsyncExample -- (start) main function 15:20:13.248764\r\n15:20:14.253 [main] INFO ...sync_async.simple.SimpleAsyncExample -- (end) main function 15:20:14.253948300\n\r\ncaller 인 main() 함수는 callee 인 getLongDelayJob() 함수가 1초가 넘게 실행이 끝날 때 까지 기다리고 있습니다.이렇게 caller 가 callee 의 결과를 알아야 다음 수행이 가능할 때 Synchronized 연산이라고 부르고, 1초가 넘도록 대기하게 되는 현상은 Blocking 이라고 부릅니다.요약해보겠습니다. 동기화는 caller 가 callee 의 결과값을 알기 위해 리턴값을 받는 동작을 의미합니다. 이때 callee 의 작업이 오래 걸리게 되어 기다리게 된다면 이렇게 기다리는 작업은 Blocking 이라고 부릅니다. 따라서 위의 예제는 블로킹 방식의 동기연산입니다.","흔한-단어의-오용--동기화-vs-블로킹#흔한 단어의 오용 : 동기화 vs 블로킹":"많은 사람들이 오해를 하는 내용이고 저 역시도 오해를 한적이 있습니다.블로킹은 하나의 연산이 오래 걸리는 것으로 인해 다른 연산들을 막고 있는 것을 의미합니다.반면 동기화는 한쪽에서 다른 한쪽의 값이 필요할 때 그 값을 가져와서 그 값을 기반으로 다른 작업을 수행하는 것을 의미합니다.교과서에 자주 나오는 동기화 예제를 보면 오래 걸리는 작업을 멀티 스레드 기반으로 돌릴때 조건변수의 동기화에 대한 예제가 많다보니 동기화는 블로킹이 일어난다는 착각이 들기 쉬운데요. 동기화와 블로킹은 개념이 가리키는 포인트가 조금 다릅니다. 동기화는 값을 맞추는 것을 의미하고, 블로킹은 어떤 작업이 오래 걸리는 것으로 인해 기다리고 있는 현상을 의미합니다. 동기화가 시간이 오래 걸리는 작업을 의미하지는 않습니다. 어떤 값을 리턴받은 것을 맞추는(싱크)하는 작업이라고 생각하면 쉽습니다.","비동기-asynchronization#비동기 (Asynchronization)":"비동기는 caller 가 callee 를 호출했을 때 callee 가 반환하는 값을 기반으로 caller 가 이 값으로 다른 작업을 수행할 필요가 없을때 주로 비동기라고 합니다. 쉽게 이야기하면 caller 가 callee 의 값을 받아서 맞출 필요가 없는 경우를 의미합니다.아래는 비동기 예제입니다. 위에서 살펴봤던 동기 방식의 예제를 비동기 버전으로 바꿨습니다. 그리고 비동기방식이지만 여전히 블로킹이 되고 있습니다.\npackage io.chagchagchag.example.foobar.concurrent.sync_async.simple;\r\n\r\nimport java.time.LocalTime;\r\nimport java.util.function.Consumer;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\n@Slf4j\r\npublic class SimpleAsyncExample {\r\n  public static void main(String [] args){\r\n    log.info(\"(start) main function \" + LocalTime.now());\r\n    execLongDelayJob(i -> {\r\n      var result = i + i;\r\n      log.info(\"result == {}\", result);\r\n    });\r\n    log.info(\"(end) main function \" + LocalTime.now());\r\n  }\r\n\r\n  public static void execLongDelayJob(Consumer<Integer> consumer){\r\n    final long current = System.currentTimeMillis();\r\n    while(true){\r\n      final long spent = System.currentTimeMillis() - current;\r\n      if(spent > 1000) break;\r\n    }\r\n\r\n    consumer.accept(500);\r\n  }\r\n}\r\n출력결과\n16:38:48.054 [main] INFO ...sync_async.simple.SimpleAsyncExample -- (start) main function 16:38:48.050013500\r\n16:38:49.062 [main] INFO ...sync_async.simple.SimpleAsyncExample -- result == 1000\r\n16:38:49.064 [main] INFO ...sync_async.simple.SimpleAsyncExample -- (end) main function 16:38:49.063973\ncaller 인 main 스레드는 여전히 callee 인 execLongDelayJob(Consumer) 의 작업이 끝나고 있기를 기다리고 있는 현상은 Blocking 입니다. 하지만, callee 인 execLongDelayJob(Consumer) 의 결과값을 알 필요는 없습니다. 이렇게 caller 가 callee 의 연산 결과를 알 필요가 없는 경우의 연산을 비동기 라고 부릅니다."}},"/nio-and-netty/java-io-java-nio-java-aio":{"title":"Java Io Java Nio Java Aio","data":{"java-io-vs-java-nio-vs-java-aio#Java IO vs Java NIO vs Java AIO":"","함수-호출-관점#함수 호출 관점":"동기\t비동기\tBlocking\tJava IO\tX\tNon-Blocking\tJava NIO(File IO 는 Non Blocking 불가)\tJava AIO\t\n함수의 호출로만 봤을 때 Java IO, Java NIO, Java AIO 는 각각 아래와 같습니다.\nJava IO : 블로킹 방식의 동기 연산입니다.\nJava NIO : 논블로킹 방식의 동기 연산입니다. 다만, File IO 는 Java NIO 에서도 Non Blocking 이 불가능합니다.\nJava AIO : 논블로킹 방식의 비동기 연산이 가능합니다.","io-모델-관점#IO 모델 관점":"동기\t비동기\tBlocking\tJava IO\tX\tNon-Blocking\tJava NIO, Java AIO\tX\t\nIO 모델 방식으로 따져봤을 때 Java IO, Java NIO, Java AIO 는 각각 아래와 같습니다.\nJava IO : 블로킹 기반의 동기 연산입니다.\nJava NIO : 논블로킹 방식의 동기 연산입니다.\nJAVA AIO : Java AIO 역시 IO 연산작업에 있어서는 블로킹 방식의 동기연산이 됩니다.","java-io#Java IO":"Java IO 는 Java 1.0 부터 처음 도입되었습니다. Java IO 는 블로킹 방식의 동기연산을 수행합니다. Java IO는 파일과 네트워크에 데이터를 읽고 쓸 수 있는 InputStream, OutputStream API를 제공합니다."}},"/nio-and-netty/what-is-aio":{"title":"What Is Aio","data":{"aio-의-개념#AIO 의 개념":""}},"/nio-and-netty/tomcat-vs-netty":{"title":"Tomcat Vs Netty","data":{}},"/concurrent-programming-basic/blocking-vs-nonblocking":{"title":"Blocking Vs Nonblocking","data":{"블로킹-vs-논블로킹#블로킹 vs 논블로킹":"","블로킹#블로킹":"블로킹 연산은 이전 문서에서 살펴봤던 동기화 예제에서 모두 살펴봤었습니다. 동기화를 논블로킹 방식으로도 수행할 수 있는데 논블로킹 방식으로 동기화를 수행하는 것은 아래에 별도의 섹션에서 정리하도록 하겠습니다.블로킹이라는 것은 어떤 작업이 끝날 때까지 이 작업을 호출한 곳에서 기다리는 것을 의미합니다. 쉽게 이야기해서 caller 가 callee 의 작업이 끝날 때 까지 기다리는 것을 의미합니다.블로킹 기반으로 동기(Synchronization) 연산을 수행하는 예제는 아래와 같습니다.","블로킹-기반의-동기synchronization-예제#블로킹 기반의 동기(Synchronization) 예제":"package io.chagchagchag.example.foobar.concurrent.sync_async.simple;\r\n\r\nimport java.time.LocalTime;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\n@Slf4j\r\npublic class SimpleSyncExample {\r\n  public static void main(String [] args){\r\n    log.info(\"(start) main function \" + LocalTime.now());\r\n    var result = getLongDelayJob();\r\n    var increased = result + 1;\r\n    assert increased == 501;\r\n    log.info(\"(end) main function \" + LocalTime.now());\r\n  }\r\n\r\n  public static int getLongDelayJob(){\r\n    long current = System.currentTimeMillis();\r\n    while(true){\r\n      long timeSpent = System.currentTimeMillis() - current;\r\n      if(timeSpent > 1000) break;\r\n    }\r\n    return 500;\r\n  }\r\n}\n출력결과\n15:20:13.250 [main] INFO ...sync_async.simple.SimpleAsyncExample -- (start) main function 15:20:13.248764\r\n15:20:14.253 [main] INFO ...sync_async.simple.SimpleAsyncExample -- (end) main function 15:20:14.253948300","블로킹-방식의-비동기asynchronization-예제#블로킹 방식의 비동기(Asynchronization) 예제":"package io.chagchagchag.example.foobar.concurrent.sync_async.simple;\r\n\r\nimport java.time.LocalTime;\r\nimport java.util.function.Consumer;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\n@Slf4j\r\npublic class SimpleAsyncExample {\r\n  public static void main(String [] args){\r\n    log.info(\"(start) main function \" + LocalTime.now());\r\n    execLongDelayJob(i -> {\r\n      var result = i + i;\r\n      log.info(\"result == {}\", result);\r\n    });\r\n    log.info(\"(end) main function \" + LocalTime.now());\r\n  }\r\n\r\n  public static void execLongDelayJob(Consumer<Integer> consumer){\r\n    final long current = System.currentTimeMillis();\r\n    while(true){\r\n      final long spent = System.currentTimeMillis() - current;\r\n      if(spent > 1000) break;\r\n    }\r\n\r\n    consumer.accept(500);\r\n  }\r\n}\r\n출력결과\n16:38:48.054 [main] INFO ...sync_async.simple.SimpleAsyncExample -- (start) main function 16:38:48.050013500\r\n16:38:49.062 [main] INFO ...sync_async.simple.SimpleAsyncExample -- result == 1000\r\n16:38:49.064 [main] INFO ...sync_async.simple.SimpleAsyncExample -- (end) main function 16:38:49.063973","논블로킹#논블로킹":"","논블로킹-방식의-동기-synchronization-예제#논블로킹 방식의 동기 (Synchronization) 예제":"논블로킹 방식으로 동기연산을 수행하려면 어떻게 해야할까요? callee 측의 작업이 오래 걸리는 작업입니다. 그런데 caller 측에서는 블로킹이 일어나지 않아야 합니다. 맞습니다. 이런 경우 callee 측의 작업을 별도의 스레드에서 수행하고 이 별도의 스레드가 끝났는지를 주기적으로 체크합니다. 그리고 작업이 끝난 것을 확인했을 때 연산 결과값을 이용해서 다음 작업을 수행합니다. 별도의 스레드가 끝났는지 주기적으로 체크하는 동안에는 다른 작업을 수행하게 될 수 있기에 논블로킹이라고 부릅니다.예제는 아래와 같습니다.\npackage io.chagchagchag.example.foobar.concurrent.sync_async;\r\n\r\nimport java.time.LocalTime;\r\nimport java.util.concurrent.ExecutionException;\r\nimport java.util.concurrent.Executors;\r\nimport java.util.concurrent.Future;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\n@Slf4j\r\npublic class SyncNonBlockingExample {\r\n  public static void main(String [] args) throws InterruptedException, ExecutionException {\r\n    log.info(\"(start) main function \" + LocalTime.now());\r\n\r\n    var count = 1;\r\n    Future<Integer> job = doLongDelayJob();\r\n    while(!job.isDone()){\r\n      log.info(String.format(\"대기 중... %s\", count++)); // 대기 중에 counting 연산을 수행\r\n      Thread.sleep(100);\r\n    }\r\n\r\n    var total = job.get() + 1;\r\n    assert total == 1112;\r\n\r\n    log.info(\"(end) main function \" + LocalTime.now());\r\n  }\r\n\r\n  public static Future<Integer> doLongDelayJob(){\r\n    var executor = Executors.newSingleThreadExecutor();\r\n    try{\r\n      return executor.submit(() -> {\r\n        long start = System.currentTimeMillis();\r\n        while(true){\r\n          long delay = System.currentTimeMillis() - start;\r\n          if(delay > 1000) break;\r\n        }\r\n        return 1111;\r\n      });\r\n    }\r\n    catch (Exception e){\r\n      e.printStackTrace();\r\n      throw new RuntimeException(\"ERROR\");\r\n    }\r\n    finally {\r\n      executor.shutdown();\r\n    }\r\n  }\r\n}\n출력결과\n18:07:59.983 [main] INFO ...sync_async.SyncNonBlockingExample -- (start) main function 18:07:59.979258800\r\n18:07:59.997 [main] INFO ...sync_async.SyncNonBlockingExample -- 대기 중... 1\r\n18:08:00.111 [main] INFO ...sync_async.SyncNonBlockingExample -- 대기 중... 2\r\n18:08:00.222 [main] INFO ...sync_async.SyncNonBlockingExample -- 대기 중... 3\r\n18:08:00.332 [main] INFO ...sync_async.SyncNonBlockingExample -- 대기 중... 4\r\n18:08:00.441 [main] INFO ...sync_async.SyncNonBlockingExample -- 대기 중... 5\r\n18:08:00.551 [main] INFO ...sync_async.SyncNonBlockingExample -- 대기 중... 6\r\n18:08:00.662 [main] INFO ...sync_async.SyncNonBlockingExample -- 대기 중... 7\r\n18:08:00.771 [main] INFO ...sync_async.SyncNonBlockingExample -- 대기 중... 8\r\n18:08:00.880 [main] INFO ...sync_async.SyncNonBlockingExample -- 대기 중... 9\r\n18:08:00.990 [main] INFO ...sync_async.SyncNonBlockingExample -- 대기 중... 10\r\n18:08:01.099 [main] INFO ...sync_async.SyncNonBlockingExample -- (end) main function 18:08:01.098719700\n출력결과에서 보이듯 caller 측에서는 100ms 마다 한번씩 자기자신의 일을 수행하면서 doLongDelayJob() 함수의 결과값을 리턴받기를 기다립니다. doLongDelayJob() 함수가 실행중일 동안 caller 가 블로킹된 것이 아니기에 논블로킹방식이라고 부릅니다.\n위의 논블로킹 방식의 동기연산을 그림으로 표현하면 아래와 같습니다.","논블로킹-방식의-비동기-synchronization-예제#논블로킹 방식의 비동기 (Synchronization) 예제":"블로킹 방식의 비동기(Asynchronization) 예제에서는 caller 가 callee 측의 연산의 결과값을 알아야 할 필요가 없음에도 caller 가 블로킹되고 있었습니다.그렇다면 caller 가 블로킹되지 않도록 논블로킹 방식으로 callee 를 호출하려면 어떻게 해야할까요? 그렇습니다. 별도의 스레드에서 callee 를 호출하고 caller 는 자신의 작업을 계속하면 됩니다.예제는 아래와 같습니다.\npackage io.chagchagchag.example.foobar.concurrent.sync_async;\r\n\r\nimport java.time.LocalTime;\r\nimport java.util.concurrent.Executors;\r\nimport java.util.function.Consumer;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\n@Slf4j\r\npublic class AsyncNonBlockingExample {\r\n  public static void main(String [] args){\r\n    log.info(\"(start) main function \" + LocalTime.now());\r\n    execLongDelayJob(i -> {\r\n      var result = 1 + i;\r\n      assert result == 1112;\r\n      log.info(\"result = {}\", result);\r\n    });\r\n    log.info(\"(end) main function \" + LocalTime.now());\r\n  }\r\n\r\n  public static void execLongDelayJob(Consumer<Integer> callback){\r\n    var executor = Executors.newSingleThreadExecutor();\r\n    try{\r\n      executor.submit(()->{\r\n        long start = System.currentTimeMillis();\r\n        while(true){\r\n          long delay = System.currentTimeMillis() - start;\r\n          if(delay > 1000) break;\r\n        }\r\n        callback.accept(1111);\r\n        log.info(\"작업이 끝났어요~!!! --- \" + LocalTime.now());\r\n        return 1111;\r\n      });\r\n    }\r\n    catch (Exception e){\r\n      e.printStackTrace();\r\n      throw new RuntimeException(\"ERROR\");\r\n    }\r\n    finally {\r\n      executor.shutdown();\r\n    }\r\n  }\r\n}\n출력결과\n18:21:05.366 [main] INFO ...sync_async.AsyncNonBlockingExample -- (start) main function 18:21:05.361457\r\n18:21:05.382 [main] INFO ...sync_async.AsyncNonBlockingExample -- (end) main function 18:21:05.381471500\r\n18:21:06.383 [pool-1-thread-1] INFO ...sync_async.AsyncNonBlockingExample -- result = 1112\r\n18:21:06.387 [pool-1-thread-1] INFO ...sync_async.AsyncNonBlockingExample -- 작업이 끝났어요~!!! --- 18:21:06.387829200\n출력결과에서 보이듯 caller 측인 메인 스레드의 호출작업이 모두 끝나고 메인스레드는 자기 자신을 종료합니다. 하지만, 별도의 스레드에서 수행되고 있는 callee 는 1초 뒤에 자기 자신이 작업을 완료했음을 로그에서 표현하고 있습니다.\n위의 논블로킹 방식의 비동기 연산을 그림으로 표현하면 아래와 같습니다."}},"/nio-and-netty/what-is-nio":{"title":"What Is Nio","data":{"java-nio#Java NIO":"Java NIO 는 Java New Input/Output 을 의미합니다. (Non blocking IO 를 의미하는 것은 아닙니다.)Java NIO 는 Java 1.4 에서 처음 도입되었고 파일과 네트워크에 데이터를 읽고 쓸 수 있는 API 를 제공하고 있습니다. 대부분의 I/O에 대해서는 논블로킹 방식의 동기 연산을 지원하지만 Java NIO 역시 File I/O 의 경우는 블로킹 방식의 동기 연산만 지원됩니다.Selector, Channel 기반으로 높은 성능을 제공하는데, 톰캣에서도 NIO가 지원되고 Netty 역시 NIO 기반으로 이루어져 있습니다. 다만 톰캣의 경우 스레드 풀 기반으로 커넥션 풀을 관리하는데 스레드를 그대로 가져다 쓰는 것으로 인해 Netty 에 비해 조금은 무거운 컨테이너입니다.JAVA IO 는 byte 또는 character 기반의 데이터 단위로 데이터를 처리하지만 Java NIO 는 buffer 단위로 데이터를 처리합니다. Java IO 에서는 흔히 잘 알려져 있는 InputStream, OutputStream 을 이용해서 데이터를 처리하지만 Java NIO 에서는 Channel 단위로 데이터를 처리합니다.지금까지의 내용을 정리해보면 아래와 같습니다.\n\tJava NIO\tJava IO\t데이터 처리 방향\t양방향\t단방향\t데이터 처리 방식\tChannel\tInputStream, OutputStream\t데이터 단위\tbuffer\tbyte, character\tnonblocking?\tFile IO를 제외한 모든 IO에 대해 논블로킹방식의 동기연산을 지원\t모든 IO 연산을 Blocking 방식의 동기연산으로만 수행 가능\tetc\tSelector 지","channel-buffer-의-개념#Channel, Buffer 의 개념":"","buffer-클래스의-종류#Buffer 클래스의 종류":"","buffer-의-주요-필드#Buffer 의 주요 필드":"","java-nio-의-주요-buffer들-커널-접근-가능-여부-등#Java NIO 의 주요 Buffer들 (커널 접근 가능 여부 등)":"","directbytebuffer#DirectByteBuffer":"DirectByteBuffer 는 off-heap 메모리에 데이터를 저장합니다. 커널 메모리에서 복사ㅡㄹ 하지 않기에 데이터를 읽고 쓰는 속도가 빠릅니다. 다만 비용이 많이 드는 System Call 을 사용하기에 allocate, deallocate가 느리다는 단점이 있습니다.allocateDirect() 함수로 생성가능합니다. 아래는 DirectByteBuffer 를 생성하는 예제 코드입니다.\nvar directByteBuffer = ByteBuffer.allocateDirect(1024);\r\nassert directByteBuffer.isDirect();","heapbytebuffer#HeapByteBuffer":"HeapByteBuffer 는 데이터를 JVM Heap 메모리에 저장합니다. byte array 를 래핑하는 Buffer 인데, 커널 메모리에서 복사해서 저장하는 버퍼이기에 복사에 대한 연산으로 인해 커널을 한번 더 IO 가 일어난다는 점에서 읽기 속도가 느리다는 단점이 있습니다. (내부적으로는 임시로 Direct Buffer 를 만드는 연산을 수행하기에 성능이 저하됩니다.)GC에 의해 관리되기에 allocate, deallocate 가 빠릅니다.allocate() 함수 또는 wrap() 함수로 생성 가능합니다. 아래는 HeapByteBuffer 를 생성하는 예제 코드 입니다.\nvar heapByteBuffer = ByteBuffer.allocate(1024);\r\nassert !heapByteBuffer.isDirect(); \r\n\r\nvar byteBufferByWrap = ByteBuffer.wrap(\"hello\".getBytes()); \r\nassert !byteBufferByWrap.isDirect();","java-nio-사용시-non-blocking-방식으로-사용하는-방법#Java NIO 사용시 Non Blocking 방식으로 사용하는 방법":"SocketChannel, ServerSeocketChannel 이 extends 하고 있는 AbstractSelectableChannel 은 SelectableChannel 을 extends 하고 있습니다.\n그리고 SelectableChannel 은 configureBlocking(boolean), register() 함수를 제공하는데 그 중 configureBlocking(boolean) 메서드를 이용해 논블로킹을 지정가능합니다.serverSocketChannel 의 accept(), socketChannel 의 connect() 사용시 위의 configureBlocking(boolean) 을 사용하면 논블로킹으로 네트워크 IO를 할지여부를 지정가능합니다.e.g. ServerSocketChannel 의 accept() 메서드를 nonblocking 하게 실행\ntry (var serverChannel = ServerSocketChannel.open()){\r\n    var address = new InetSocketAddress(\"localhost\", 8080);\r\n    serverChannel.bind(address);\r\n    serverChannel.configureBlocking(false); /// nonblocking 설정 \r\n    \r\n    var clientSocket = serverChannel.accept(); \r\n    assert clientSocket !== null;\r\n}\ne.g. SocketChannel 의 connect() 메서드를 nonblocking 하게 실행\ntry (var socketChannel = SocketChannel.open()){\r\n    var address = new InetSocketAddress(\"localhost\", 8080);\r\n    socketChannel.configureBlocking(false);\r\n    var connected = socketChannel.connect(address);\r\n    assert !connected;\r\n}"}},"/r2dbc-mysql/example":{"title":"Example","data":{}},"/reactive-mongodb/example":{"title":"Example","data":{}},"/reactive-programming/intro":{"title":"Intro","data":{"intro#intro":""}},"/reactive-programming/reactive-programming":{"title":"Reactive Programming","data":{"reactive-programming#Reactive Programming":"Reactive Programming 이란?\r\n비동기 데이터 stream 을 사용하는 패러다임입니다. Reactive Programming 방식은 Event Driven 한 방식의 프로그래밍 방식입니다. 모든 것이 이벤트로 구성되고 이벤트를 통해서 전파되어야 합니다.\r\n데이터의 전달, 에러, 완료까지도 모두 이벤트로 취급됩니다.\nReactive Programming 은 RectiveMenifesto 에서 언급하는 4가지 원칙인 Responsive, Resilient, Elastic, Message Driven 을 모두 충족합니다.\n동기 Stream\nstream 을 이용한 흐름\n비동기 future란?\nfuture 를 이용한 처리 흐름의 단점\nReactive Stream 이란?","event-driven-과-message-driven-의-차이점#Event Driven 과 Message Driven 의 차이점":"","publisher-subscriber-예제#Publisher, Subscriber 예제":""}},"/nio-and-netty/java-socket-communication":{"title":"Java Socket Communication","data":{"java-의-socket-통신#Java 의 Socket 통신":""}},"/reactive-programming/reactor-pattern":{"title":"Reactor Pattern","data":{}},"/reactive-programming/what-is-reactive":{"title":"What Is Reactive","data":{"reactive-란#Reactive 란?":""}},"/reactive-programming/proactor-pattern":{"title":"Proactor Pattern","data":{}},"/r2dbc-mysql/what-is-r2dbc":{"title":"What Is R2dbc","data":{}},"/reactive-programming/what-is-epool":{"title":"What Is Epool","data":{}},"/server-sent-event/what-is-sse":{"title":"What Is Sse","data":{"server-sent-event#Server Sent Event":"","polling#Polling":"주"}},"/server-sent-event/example":{"title":"Example","data":{}},"/webflux-websocket/example":{"title":"Example","data":{}}}