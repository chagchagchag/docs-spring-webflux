## Reactor 프로그래밍 (스압 주의)

Spring Webflux 는 pivotal 사에서 개발한 project reactor 를 기반으로 한 서버 애플리케이션을 개발하기 위한 Web 프레임워크입니다.<br/>



## Flux, Mono

> 참고
>
> - Flux : [projectreactor.io - Flux](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html)
> - Mono : [projectreactor.io - Mono](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html)
> - Publiser : [reactive-streams - Publisher](https://github.com/reactive-streams/reactive-streams-jvm/blob/master/api/src/main/java/org/reactivestreams/Publisher.java)
> - Subscriber : [reactive-streams - Subscriber](https://github.com/reactive-streams/reactive-streams-jvm/blob/master/api/src/main/java/org/reactivestreams/Subscriber.java)

<br/>



- Flux : 
  - Java 의 List 와 유사한 데이터의 흐름입니다. 두개 이상의 데이터의 흐름입니다.
  - [projectreactor.io - Flux](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html) 을 보면 알 수 있듯 Publisher 를 implements 한 클래스이기에 자료구조라기보다는, 데이터의 흐름이라는 사실을 기억해주시기 바랍니다.
- Mono : 
  - 하나만 존재하는 데이터를 의미합니다.
  - [projectreactor.io - Mono](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html) 을 보면 알 수 있듯 Publisher 를 implements 한 클래스이기에 자료구조라기보다는 데이터의 흐름이라는 사실을 기억해주시기 바랍니다.

<br/>

Flux 하나만 쓰면 될것 같은데 Mono 가 존재하는 이유에 대해 생각이 들 수 있습니다. Mono 라는 자료형이 존재하는 것으로 인한 장점은 아래와 같습니다.

- 하나만 존재하는 데이터의 흐름(Response, Count 결과값 등) 일 경우 onNext 이후에 바로 onComplete 를 하면 되기 때문에 구현이 더 명확해지게 됩니다.
- Mono 라는 Publisher 를 받는 Subscriber 측 역시 1개의 요소만 처리해야 한다는 사실을 알 수 있기 때문에 조금 더 구현이 명확해집니다.

<br/>



## sequence

Mono,Flux 를 이용해서 다양한 데이터의 흐름을 만들어봅니다. Mono, Flux 를 통해서 만들어내는 데이터의 흐름을 일반적으로 `sequence` 라고 부릅니다.<br/>

<br/>



### just

Mono.just(), Flux.just() 메서드를 사용하면 시퀀스를 생성할 수 있습니다. 자세한 내용은 예제와 출력결과를 확인해주시기 바랍니다.

`JustExample.java`

```java
package io...sequence;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
public class JustExample {
  public static void main(String[] args) {
    Mono.just("안녕하세요")
        .subscribe(v -> {
          log.info(">>> {}", v);
        });

    Flux.just("MSFT", "NVDA", "SMCI")
        .subscribe(v -> {
          log.info(">>> {}", v);
        });
  }
}
```

<br/>

출력결과

```plain
15:18:07.066 [main] INFO io...sequence.JustExample -- >>> 안녕하세요
15:18:07.228 [main] INFO io...sequence.JustExample -- >>> MSFT
15:18:07.228 [main] INFO io...sequence.JustExample -- >>> NVDA
15:18:07.228 [main] INFO io...sequence.JustExample -- >>> SMCI

Process finished with exit code 0
```

<br/>



### error

Mono.error, Flux.error 를 사용하면 subscriber 에게 onError 이벤트를 전달할 수 있습니다.<br/>

반드시 **"subscriber 에게 onError 이벤트를 전달한다."**라는 의미를 꼭 기억해주셨으면 합니다.<br/>

```java
package io...sequence;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
public class ErrorExample {

  public static void main(String[] args) {
    Mono.error(new IllegalArgumentException("어머, 에러에요"))
        .subscribe(
            v -> {log.info("v ::: " + v);},
            error -> {log.error("error ::: " + error);}
        );

    Flux.error(new IllegalArgumentException("어머, 에러에요"))
        .subscribe(
            v -> {log.info("value ::: " + v);},
            error -> {log.error("error ::: " + error);}
        );
  }
}

```

<br/>



출력결과

```plain
15:27:13.589 [main] ERROR io...sequence.ErrorExample -- error ::: java.lang.IllegalArgumentException: 어머, 에러에요
15:27:13.699 [main] ERROR io...sequence.ErrorExample -- error ::: java.lang.IllegalArgumentException: 어머, 에러에요

Process finished with exit code 0
```

<br/>



### empty

Mono.empty, Flux.empty 를 써보는 예제입니다. empty 를 사용하면 Mono 또는 Flux 에게 onComplete 이벤트만 전달되게 됩니다.

```java
package io...sequence;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
public class EmptyExample {
  public static void main(String[] args) {
    Mono.empty()
        .subscribe(
            v -> {log.info("value === " +v);},
            null,
            () -> {log.info("complete");}
        );

    Flux.empty()
        .subscribe(
            v -> {log.info("value === " + v);},
            null,
            () -> {log.info("complete");}
        );
  }
}
```

<br/>



출력결과

```plain
15:31:46.735 [main] INFO io...sequence.EmptyExample -- complete
15:31:46.792 [main] INFO io...sequence.EmptyExample -- complete

Process finished with exit code 0
```

<br/>



### Mono.fromOOO()

Mono.from 으로 시작하는 함수들은 아래와 같습니다.

- Mono.fromCallable
  - Callable 함수형 인터페이스를 람다로 실행 후 반환값은 onNext 로 전달됩니다.
- Mono.formFuture
  - Future 를 받아서 done 상태가 되었을 때 반환값을 onNext 로 Subscriber 에 전달합니다.
- Mono.fromSupplier
  - Supplier 함수형 인터페이스를 람다로 실행 후 반환값은 onNext 로 Subscriber 에 전달합니다.
- Mono.fromRunnable
  - Runnable 함수형 인터페이스를 람다로 실행 후, onComplete 를 Subscriber 에 전달합니다.

<br/>



```java
package io...sequence;

import java.util.concurrent.CompletableFuture;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

@Slf4j
public class MonoFromExample {
  public static void main(String[] args) {
    Mono.fromCallable(() -> {
      return "삼성전자";
    }).subscribe(v -> {
      log.info("fromCallable 에서 받은 value === " + v);
    });

    Mono.fromFuture(CompletableFuture.supplyAsync(() -> {
      return "삼성전자";
    })).subscribe(v -> {
      log.info("fromFuture 로부터 받은 value === " + v);
    });

    Mono.fromSupplier(() -> {
      return "삼성전자";
    }).subscribe(v -> {
      log.info("fromSupplier 로부터 받은 value === " + v);
    });

    Mono.fromRunnable(() -> {
      log.info("do some runnable");
    }).subscribe(
        null, null, () -> {log.info("fromRunnable Complete.");}
    );
  }
}
```

<br/>



출력결과

```plain
15:45:03.043 [main] INFO io...sequence.MonoFromExample -- fromCallable 에서 받은 value === 삼성전자
15:45:03.049 [main] INFO io...sequence.MonoFromExample -- fromFuture 로부터 받은 value === 삼성전자
15:45:03.051 [main] INFO io...sequence.MonoFromExample -- fromSupplier 로부터 받은 value === 삼성전자
15:45:03.052 [main] INFO io...sequence.MonoFromExample -- do some runnable
15:45:03.052 [main] INFO io...sequence.MonoFromExample -- fromRunnable Complete.

Process finished with exit code 0
```

<br/>



### Flux.fromOOO()

Flux.from 으로 시작하는 함수들은 아래와 같습니다.

- Flux.fromIterable
- Flux.fromStream
- Flux.fromArray
- Flux.range(start, n)



```java
package io...sequence;

import java.util.List;
import java.util.stream.IntStream;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;

@Slf4j
public class FluxFromExample {
  public static void main(String[] args) {
    Flux.fromIterable(List.of("MSFT", "NVDA", "SMCI"))
        .subscribe(v -> {log.info("value ==> " + v);});

    Flux.fromStream(IntStream.range(1,10).boxed())
        .subscribe(v -> {log.info("value ==> " + v);});

    Flux.fromArray(new Integer[]{1,2,3,4,5,6,7,8,9,10})
        .subscribe(v -> {log.info("value ==> " + v);});

    Flux.range(1,10)
        .subscribe(v -> {log.info("value ==> " + v);});
  }
}
```

<br/>



출력결과

```plain
15:53:24.737 [main] INFO io...sequence.FluxFromExample -- value ==> MSFT
15:53:24.740 [main] INFO io...sequence.FluxFromExample -- value ==> NVDA
15:53:24.740 [main] INFO io...sequence.FluxFromExample -- value ==> SMCI
15:53:24.746 [main] INFO io...sequence.FluxFromExample -- value ==> 1
15:53:24.746 [main] INFO io...sequence.FluxFromExample -- value ==> 2
15:53:24.746 [main] INFO io...sequence.FluxFromExample -- value ==> 3
15:53:24.747 [main] INFO io...sequence.FluxFromExample -- value ==> 4
15:53:24.747 [main] INFO io...sequence.FluxFromExample -- value ==> 5
15:53:24.747 [main] INFO io...sequence.FluxFromExample -- value ==> 6
15:53:24.747 [main] INFO io...sequence.FluxFromExample -- value ==> 7
15:53:24.747 [main] INFO io...sequence.FluxFromExample -- value ==> 8
15:53:24.747 [main] INFO io...sequence.FluxFromExample -- value ==> 9
15:53:24.749 [main] INFO io...sequence.FluxFromExample -- value ==> 1
15:53:24.749 [main] INFO io...sequence.FluxFromExample -- value ==> 2
15:53:24.749 [main] INFO io...sequence.FluxFromExample -- value ==> 3
15:53:24.749 [main] INFO io...sequence.FluxFromExample -- value ==> 4
15:53:24.749 [main] INFO io...sequence.FluxFromExample -- value ==> 5
15:53:24.749 [main] INFO io...sequence.FluxFromExample -- value ==> 6
15:53:24.749 [main] INFO io...sequence.FluxFromExample -- value ==> 7
15:53:24.749 [main] INFO io...sequence.FluxFromExample -- value ==> 8
15:53:24.749 [main] INFO io...sequence.FluxFromExample -- value ==> 9
15:53:24.749 [main] INFO io...sequence.FluxFromExample -- value ==> 10
15:53:24.751 [main] INFO io...sequence.FluxFromExample -- value ==> 1
15:53:24.751 [main] INFO io...sequence.FluxFromExample -- value ==> 2
15:53:24.751 [main] INFO io...sequence.FluxFromExample -- value ==> 3
15:53:24.751 [main] INFO io...sequence.FluxFromExample -- value ==> 4
15:53:24.751 [main] INFO io...sequence.FluxFromExample -- value ==> 5
15:53:24.751 [main] INFO io...sequence.FluxFromExample -- value ==> 6
15:53:24.751 [main] INFO io...sequence.FluxFromExample -- value ==> 7
15:53:24.751 [main] INFO io...sequence.FluxFromExample -- value ==> 8
15:53:24.751 [main] INFO io...sequence.FluxFromExample -- value ==> 9
15:53:24.751 [main] INFO io...sequence.FluxFromExample -- value ==> 10

Process finished with exit code 0
```

<br/>



### Flux.generate

generate 는 동기적으로 Flux 를 생성합니다.<br/>

[Flux.java(github)](https://github.com/reactor/reactor-core/blob/main/reactor-core/src/main/java/reactor/core/publisher/Flux.java) 내에 선언된 generate() 메서드는 세 종류의 메서드가 있는데 그 중 한 가지는 아래와 같습니다.

```java
public abstract class Flux<T> implements CorePublisher<T>{
    // ...
    public static <T, S> Flux<T> generate(Callable<S> stateSupplier, BiFunction<S, SynchronousSink<T>, S> generator) {
		return onAssembly(new FluxGenerate<>(stateSupplier, generator));
	}
    // ...

}
```

<br/>

stateSupplier 

- 초기값을 제공하는 역할의 callable 입니다.

generator

- 첫번째 인자로는 state 를 제공합니다. 그리고 이 state 에 대해 변경된 state 를 반환합니다.
- 두번째 인자로 SynchronousSink 를 제공합니다. 이 sink 객체의 next, error, complete 메서드를 이용해서 Subscriber 에게 onNext, onError, onComplete 이벤트를 전달하는 것이 가능합니다. 
- 한번의 generator 에서는 최대 한번만 next 를 호출 가능합니다.

<br/>



#### 1) sink.next()

```java
package io...sequence;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;

@Slf4j
public class FluxGenerateExample1 {
  public static void main(String[] args) {
    Flux.generate(
        () -> 0,
        (state, sink) -> {
          sink.next(state);
          if(state == 9) sink.complete();
          return state + 1;
        }
    ).subscribe(
        v -> {log.info("value === " + v);},
        error -> {log.error("error === " + error);},
        () -> {log.info("complete !!");}
    );
  }
}
```

<br/>



초기값은 0 으로 세팅해줬습니다. 매 순간 다음 스텝의 연산을 수행하는 것은 state + 1 을 통해서 다음 스텝의 연산을 합니다. 그리고 state 가 9 가 되었을 때는 sink 객체의 complete() 메서드를 호출해서 onComplete 신호를 방출합니다. <br/>

자세히 보면 FSM, CPS 연산과 닮아있음을 알 수 있습니다.<br/>

<br/>



출력결과

```plain
16:07:48.178 [main] INFO io...sequence.FluxGenerateExample1 -- value === 0
16:07:48.180 [main] INFO io...sequence.FluxGenerateExample1 -- value === 1
16:07:48.180 [main] INFO io...sequence.FluxGenerateExample1 -- value === 2
16:07:48.180 [main] INFO io...sequence.FluxGenerateExample1 -- value === 3
16:07:48.180 [main] INFO io...sequence.FluxGenerateExample1 -- value === 4
16:07:48.180 [main] INFO io...sequence.FluxGenerateExample1 -- value === 5
16:07:48.180 [main] INFO io...sequence.FluxGenerateExample1 -- value === 6
16:07:48.180 [main] INFO io...sequence.FluxGenerateExample1 -- value === 7
16:07:48.180 [main] INFO io...sequence.FluxGenerateExample1 -- value === 8
16:07:48.180 [main] INFO io...sequence.FluxGenerateExample1 -- value === 9
16:07:48.180 [main] INFO io...sequence.FluxGenerateExample1 -- complete !!

Process finished with exit code 0
```

<br/>



#### 2\) sink.next()를 두번 호출하면? 에러발생

```java
package io.chagchagchag.example.foobar.spring_webflux.sequence;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;

@Slf4j
public class FluxGenerateExample2 {
  public static void main(String[] args) {
    Flux.generate(
        () -> 0,
        (state, sink) -> {
          sink.next(state);
          sink.next(state);
          if(state == 9) sink.complete();

          return state + 1;
        }
    ).subscribe(
        v -> { log.info("value === " + v); },
        error -> { log.error("error === " + error); },
        () -> { log.info("complete"); }
    );
  }
}
```

<br/>



generate 에서 sink 객체를 이용해서 next() 함수를 통해 onNext 이벤트를 두번 호출해보면 에러가 나는 것을 확인 가능합니다.<br/>



출력결과

```plain
16:14:41.992 [main] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxGenerateExample2 -- value === 0
16:14:41.994 [main] ERROR io.chagchagchag.example.foobar.spring_webflux.sequence.FluxGenerateExample2 -- error === java.lang.IllegalStateException: More than one call to onNext

Process finished with exit code 0
```

<br/>



### Flux.create()

[Flux.java(github)](https://github.com/reactor/reactor-core/blob/main/reactor-core/src/main/java/reactor/core/publisher/Flux.java) 내에 선언된 create() 메서드는 아래와 같습니다.

```java
public abstract class Flux<T> implements CorePublisher<T>{
    // ...
    public static <T> Flux<T> create(Consumer<? super FluxSink<T>> emitter) {
	    return create(emitter, OverflowStrategy.BUFFER);
    }
    // ...
}
```

<br/>

Flux.craete() 는 Flux 를 비동기적으로 생성합니다. 중간에 있는 인자를 보면 FluxSink 가 Consumer 의 인자로 되는 것을 알 수 있습니다. 이 FluxSink 를 이용해서 next(), error(), complete() 메서드를 호출해서 Subscriber 에게 onNext, onError, onComplete 신호를 발생시킬 수 있습니다.<br/>

위에서 살펴본 Flux.generate() 에서 사용하던 SynchronousSink 와는 다르게 여러번 next() 를 호출하는 것이 가능합니다. 그리고 **Flux.create() 는 여러 스레드에서 동시에 호출가능**합니다.<br/>

예제

```java
package io.chagchagchag.example.foobar.spring_webflux.sequence;

import java.util.concurrent.CompletableFuture;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;

@Slf4j
public class FluxCreateExample {
  @SneakyThrows
  public static void main(String[] args) {
    Flux.create(fluxSink -> {
      var task1 = CompletableFuture.runAsync(() -> {
        for (int i=0; i<5; i++){
          fluxSink.next(i);
        }
      });

      var task2 = CompletableFuture.runAsync(() -> {
        for (int i=5; i<10; i++){
          fluxSink.next(i);
        }
      });

      CompletableFuture.allOf(task1, task2)
          .thenRun(fluxSink::complete);
    }).subscribe(
        v -> {log.info("value === " + v);},
        error -> {log.error("error === " + error);},
        () -> {log.info("complete");}
    );

    Thread.sleep(1000);
  }
}
```

<br/>



0\~4 까지의 숫자를 sink.next 하는 스레드, 5 \~ 9 까지의 숫자를 sink.next 하는 스레드 이렇게 두개의 스레드를 이용해서 sink.next 를 수행하며, CompletableFuture.allOf 를 통해서 두 개의 CompletableFuture 객체 task1, task2 작업이 끝난 시점에 fluxSink 객체를 이용해서 Subscriber 에게 complete 신호를 내보냅니다.<br/>



출력결과<br/>

```plain
16:24:55.472 [ForkJoinPool.commonPool-worker-1] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxCreateExample -- value === 0
16:24:55.474 [ForkJoinPool.commonPool-worker-1] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxCreateExample -- value === 5
16:24:55.474 [ForkJoinPool.commonPool-worker-1] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxCreateExample -- value === 6
16:24:55.474 [ForkJoinPool.commonPool-worker-1] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxCreateExample -- value === 7
16:24:55.474 [ForkJoinPool.commonPool-worker-1] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxCreateExample -- value === 8
16:24:55.474 [ForkJoinPool.commonPool-worker-1] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxCreateExample -- value === 9
16:24:55.474 [ForkJoinPool.commonPool-worker-1] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxCreateExample -- value === 1
16:24:55.474 [ForkJoinPool.commonPool-worker-1] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxCreateExample -- value === 2
16:24:55.474 [ForkJoinPool.commonPool-worker-1] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxCreateExample -- value === 3
16:24:55.474 [ForkJoinPool.commonPool-worker-1] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxCreateExample -- value === 4
16:24:55.475 [ForkJoinPool.commonPool-worker-1] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxCreateExample -- complete

Process finished with exit code 0
```

<br/>



### Flux.handle()

[Flux.java(github)](https://github.com/reactor/reactor-core/blob/main/reactor-core/src/main/java/reactor/core/publisher/Flux.java) 내에 선언된 handle() 메서드는 아래와 같습니다.

```java
public abstract class Flux<T> implements CorePublisher<T>{
    // ...
    public final <R> Flux<R> handle(BiConsumer<? super T, SynchronousSink<R>> handler) {
		if (this instanceof Fuseable) {
			return onAssembly(new FluxHandleFuseable<>(this, handler));
		}
		return onAssembly(new FluxHandle<>(this, handler));
	}
    // ...
}
```

<br/>



Flux.handle() 메서드는 현재 존재하는 source 에 대해 handle 작업을 처리하는 함수입니다. 위 코드에서 `handler` 라는 BiConcumer 의 인자값에 대한 설명은 아래와 같습니다.<br/>

`? super T`

- source 에서 제공하는 데이터흐름에 대한 각 요소를 의미하는 item 입니다.

`SynchronousSink<R>`

- sink 의 next 연산을 이용해서 현재 주어진 item 을 전달할지 말지 결정합니다.

<br/>



source 의 item 을 필터링 하는 등 interceptor 같은 역할을 하게끔 구현가능합니다.<br/>

<br/>



예제

```java
package io.chagchagchag.example.foobar.spring_webflux.sequence;

import java.util.stream.IntStream;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;

@Slf4j
public class FluxHandleExample {
  public static void main(String[] args) {
    Flux.fromStream(IntStream.range(0,11).boxed())
        .handle((v, sink) -> {
          if(v%2 == 0) sink.next(v);
        }).subscribe(
            v -> {log.info("value === " + v);},
            error -> {log.error("error === " + error);},
            () -> {log.info("complete");}
        );
  }
}

```



짝수 숫자에 대해서만 다음으로 넘어갈 수 있도록 sink 를 이용해서 next() 함수를 호출해서 Subscriber 에게 onNext 신호를 방출합니다.<br/>



출력결과

```plain
16:37:34.735 [main] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxHandleExample -- value === 0
16:37:34.737 [main] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxHandleExample -- value === 2
16:37:34.737 [main] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxHandleExample -- value === 4
16:37:34.737 [main] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxHandleExample -- value === 6
16:37:34.737 [main] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxHandleExample -- value === 8
16:37:34.737 [main] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxHandleExample -- value === 10
16:37:34.738 [main] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.FluxHandleExample -- complete

Process finished with exit code 0
```

<br/>



## subscribe(), Subscriber

Flux, Mono 와 같은 Publisher 는 subscribe 를 하지 않으면 아무 일도 일어나지 않습니다. 예를 들면 아래와 같은 코드는 아무 일도 일어나지 않으며 그냥 표현식일 뿐입니다.

```java
Flux.fromIterable(List.of("배고파요", "밥먹어요", "배불러요"))
    .doOnNext(v -> {log.info(">>> " + v);});
```

<br/>



### subscribe()

예를 들어 Flux 의 코드를 보면, subscribe() 함수는 아래와 같은 메서드들이 있습니다. 오버로딩 된 여러가지 메서드들이 있지만, 가장 대표적인 메서드 들은 아래와 같습니다.

```java
package reactor.core.publisher;

// ...

public abstract class Flux<T> implements CorePublisher<T> {
    public final Disposable subscribe() {
		return subscribe(null, null, null);
	}
    
    public final Disposable subscribe(
			@Nullable Consumer<? super T> consumer,
			@Nullable Consumer<? super Throwable> errorConsumer,
			@Nullable Runnable completeConsumer,
			@Nullable Context initialContext) {
		return subscribeWith(new LambdaSubscriber<>(consumer, errorConsumer,
				completeConsumer,
				null,
				initialContext));
	}
    
    @Override
	@SuppressWarnings("unchecked")
	public final void subscribe(Subscriber<? super T> actual) {
		// ...
	}
}
```

<br/>



- subscribe()
  - 별도의 Consumer 를 전달 받지 않은 채로 subscribe 합니다.
- subscribe (consumer, errorConsumer, completeConsumer, initialContext)
  - 함수형 인터페이스를 이용해서 subscribe 를 합니다. Disposable 을 반환해서 이 Disposable 을 이용해서 언제든지 연결을 종료하는 것이 가능합니다.
- subscribe (Subscriber)
  - 별도의 Subscriber 를 전달받아서 subscribe 합니다.
  - 예를 들면 [BaseSubscriber](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/BaseSubscriber.html) 같은 Subscriber 를 인자로 전달하거나, 비즈니스 로직에 따라 특수하게 [BaseSubscriber](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/BaseSubscriber.html) 를 별도로 확장(extends)한 커스텀한 Subscriber 를 넘겨줘서 subscribe 하는 경우도 있습니다.
  - [BaseSubscriber](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/BaseSubscriber.html) 는 project reactor 에서 제공하는 배압관리를 위해 필요한 것들이 잘 갖춰져 있는 클래스입니다.
  - 이때 Subscriber 는 subscription 을 Publisher 로부터 전달 받습니다. 그리고 이 subscription 객체를 이용해서 request를 통해서 backpressure 를 조절하거나, cancel 을 통해서 연결 종료할 수 있습니다.
  - Subscriber 를 직접 작성할 경우에 어떻게 작성하는지 궁금하시다면 [Publisher, Subscriber, Supscription, Backpressure 문서](https://chagchagchag.github.io/docs-spring-webflux/reactive-programming/publisher-subscriber-subscription-backpressure/) 를 참고해주시기 바랍니다.

<br/>



#### subscribe()

Publiser 에서 데이터의 흐름을 만들긴 하지만, 이 데이터들을 Subscriber 측에서 받아서 별도의 처리를 할 필요가 없이 뒷단에서만 동작하게끔 해야 할 경우 단순한 형태의 subscribe() 메서드를 사용합니다.

```java
@Slf4j
public class Subscribe1Example {
  public static void main(String[] args) {
    Flux.fromIterable(List.of("배고파요", "밥먹어요", "배불러요"))
        .doOnNext(v -> { save(v);})
        .subscribe();
  }

  public static void save(String s){
    log.info("SAVE DATA >>> " + s);
  }
}
```

<br/>

doOnNext()<br/>

- 결과를 확인하고 싶을 때나, 지나가는 값들을 통해서 별도의 작업을 확인하고 싶을 때 사용합니다.

<br/>



출력결과

```plain
17:26:42.596 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe1Example -- SAVE DATA >>> 배고파요
17:26:42.598 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe1Example -- SAVE DATA >>> 밥먹어요
17:26:42.598 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe1Example -- SAVE DATA >>> 배불러요

Process finished with exit code 0
```

<br/>



#### subscribe (consumer, errorConsumer, completeConsumer, initialContext)

정상일때, 에러일때, onComplete 일때 어떤것을 할지, initialContext 를 정의합니다.

```java
package io.chagchagchag.example.foobar.spring_webflux.subscribe;

import java.util.List;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.util.context.Context;

@Slf4j
public class Subscribe2Example {
  public static void main(String[] args) {
    Flux.fromIterable(List.of("배고파요", "밥먹어요", "배불러요"))
        .subscribe(
            v -> {log.info("value === " + v);},
            error -> {log.error("error === " + error);},
            () -> {log.info("complete");},
            Context.empty()
        );
  }
}

```

<br/>

consumer 

- 인자값을 받아서 해야 할 일을 Consumer 함수형 인터페이스에 맞게 구현합니다.

errorConsumer

- errorConsumer 에는 에러를 인자로 받아서 처리하는 Consumer 를 넘겨주면 됩니다.

completeConsumer

- onComplete 신호가 발생했을 때 실행할 Runnable 인터페이스의 람다 바디를 이곳에 정의해줍니다.

initialContext

- upstream 에 전달할 context 입니다.

<br/>



출력결과

```plain
17:31:30.686 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe2Example -- value === 배고파요
17:31:30.688 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe2Example -- value === 밥먹어요
17:31:30.688 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe2Example -- value === 배불러요
17:31:30.689 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe2Example -- complete

Process finished with exit code 0
```

<br/>



#### subscribe (Subscriber)

Publisher 가 Subscription 에 어떤 Subscriber 를 등록할지를 직접 지정합니다.

```java
package io.chagchagchag.example.foobar.spring_webflux.subscribe;

import java.util.List;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.BaseSubscriber;
import reactor.core.publisher.Flux;

@Slf4j
public class Subscribe3Example {
  public static void main(String[] args) {
    var subscriber = new BaseSubscriber<String>(){
      @Override
      protected void hookOnNext(String value) {
        log.info("value === " + value);
      }

      @Override
      protected void hookOnComplete() {
        log.info("complte");
      }
    };

    Flux.fromIterable(List.of("배고파요", "밥먹어요", "배불러요"))
        .subscribe(subscriber);
  }
}
```

<br/>



출력결과

```plain
18:47:08.696 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe3Example -- value === 배고파요
18:47:08.699 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe3Example -- value === 밥먹어요
18:47:08.699 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe3Example -- value === 배불러요
18:47:08.699 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe3Example -- complte

Process finished with exit code 0
```

<br/>



### BaseSubscriber

예제에서 사용한 [BaseSubscriber](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/BaseSubscriber.html) 는 projectreactor 에서 제공하는 [BaseSubscriber](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/BaseSubscriber.html) 를 사용했습니다.<br/>

BaseSubscriber 내의  hookOnNext(), hookOnComplete(), hookOnError(), hookOnSubscribe() 를  override 해서 cancel, request 를 별도로 호출할 수 있도록 정의할 수 있습니다.<br/>

<br/>

####  backpressure 관리함수 : request(n)

**Publisher 에게 "아이템을 n 만큼씩 주세요" 하면서 그 속도를 조절하는 함수**입니다.<br/>

Subscriber 외부에서 request(n) 을 통해 요청할 수 있어서 backpressure 의 속도를 조절하는 등의 작업을 할 때 유용하게 쓰입니다.<br/>

예를 들어 아래의 코드는 Subscriber interface 에서 제공하는 backpressure 함수인 request () 함수를 이용했습니다. hookOnSubscribe() 에서 request(1) 을 통해서 1만큼 읽어들이겠다고 하는 방식으로 backpressure 관리 코드를 작성했습니다.<br/>

```java
package io.chagchagchag.example.foobar.spring_webflux.subscribe;

import java.util.List;
import lombok.extern.slf4j.Slf4j;
import org.reactivestreams.Subscription;
import reactor.core.publisher.BaseSubscriber;
import reactor.core.publisher.Flux;

@Slf4j
public class Subscribe4Example {
  public static void main(String[] args) {
    var subscriber = new BaseSubscriber<String>(){
      @Override
      protected void hookOnSubscribe(Subscription subscription) {
        request(1); // backpressure 함수인 reuest(n) 호출
      }

      @Override
      protected void hookOnNext(String value) {
        log.info("value === " + value);
      }

      @Override
      protected void hookOnComplete() {
        log.info("complte");
      }
    };

    Flux.fromIterable(List.of("배고파요", "밥먹어요", "배불러요"))
        .subscribe(subscriber);
  }
}
```

<br/>



출력결과

```plain
19:04:26.426 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe4Example -- value === 배고파요

Process finished with exit code 0
```

<br/>



#### backpressure 관리함수 : requestUnbounded() 

requestUnbounded() 는 request(Long.MAX\_VALUE) 로 실행되는데, <br/>

Publisher 에게 "가능한 빠르게 아에템을 전달해주세요"와 같은 의미의 요청입니다.<br/>

Subscriber 외부에서 request(n) 을 통해 요청할 수 있어서 backpressure 의 속도를 조절하는 등의 작업을 할 때 유용하게 쓰입니다.<br/>

request 를 거의 무한대에 가까운 숫자로 요청하기에 가지고 있는 것들을 모두 한번에 보내주세요 라는 의미와 같습니다. 또한 backpressure 의 속도를 조절하지 않고 한번에 요청하므로 거의 backpressure 를 비활성화 한것과 같은 효과를 냅니다.<br/>

BaseSubscriber 의 기본 전략은 requestUnbounded() 입니다.<br/>

<br/>



#### requestUnbounded(), request(Long.MAX\_VALUE) 가 발생하는 경우

아래와 같은 경우에 request(Long.MAX\_VALUE) 와 같은 요청이 발생됩니다.

- 아무 인자 없이 사용되는 subscribe() 함수 
- BaseSubscriber 의 hookOnSubscribe() 를 그대로 사용할 경우
- BaseSubscriber 를 재정의 없이 그냥 사용할 경우
- block(), blockFirst(), blockLast() 등의 blocking 연산자를 사용할 경우 
- toIterable(), toStream() 등의 toCallect 연산자를 사용할 경우

<br/>



BasePublisher 는 위에서 살펴봤던 request(n) 과 같은 backpressure 를 관리하는 함수를 조금 더 다양하게 사용할 수 있는 함수를 제공합니다.<br/>

<br/>



#### buffer(n)

BasePublisher 는 위에서 살펴봤던 request(n) 과 같은 backpressure 를 관리하는 함수를 조금 더 다양하게 사용할 수 있는 함수 인 buffer(n) 을 제공합니다.

```java
package io.chagchagchag.example.foobar.spring_webflux.subscribe;

import java.util.List;
import java.util.stream.IntStream;
import lombok.extern.slf4j.Slf4j;
import org.reactivestreams.Subscription;
import reactor.core.publisher.BaseSubscriber;
import reactor.core.publisher.Flux;

@Slf4j
public class Buffer1Example {
  public static void main(String[] args) {
    var subscriber = new BaseSubscriber<List<Integer>>(){
      @Override
      protected void hookOnSubscribe(Subscription subscription) {
        request(2);
      }

      @Override
      protected void hookOnNext(List<Integer> value) {
        log.info("value = " + value);
      }

      @Override
      protected void hookOnComplete() {
        log.info("complete");
      }
    };

    Flux.fromStream(IntStream.range(0,20).boxed())
        .buffer(3)
        .subscribe(subscriber);
  }
}
```



(request = 2) x (buffer = 3) = 6 입니다.

한번의 요청에 size 가 3 인 List 를 buffer 로 전달하고 이것을 requet(2) 를 통해 한번의 엘리먼트에서 (3개짜리 리스트) 를 2회 요청하는 효과를 냅니다.<br/>

출력결과는 아래와 같습니다.<br/>

```plain
19:38:07.365 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Buffer1Example -- value = [0, 1, 2]
19:38:07.367 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Buffer1Example -- value = [3, 4, 5]

Process finished with exit code 0
```

<br/>



#### take(n, limitRequest)

BasePublisher 는 위에서 살펴봤던 request(n) 과 같은 backpressure 를 관리하는 함수를 조금 더 다양하게 사용할 수 있는 함수인 take(n, limitRequest) 를 제공합니다.<br/>

Publisher 에는 데이터가 수천만개가 있을 수 있습니다. 하지만 데이터를 SQL의 limit 문 처럼 원하는 갯수만 구독하려 할 경우에는 take(n, limitRequest) 를 사용합니다.<br/>

그런데 take(n, limitRequest) 함수는 n개를 지정했더라도 정확하게 n개만큼 딱 떨어지게 끊지 못하는 경우도 있는데 limitRequest == true 로 설정할 경우에는 정확하게 n개 만큼을 take 할 수 있게 됩니다. 만약 limitRequest == false 일 경우 정확히 n 개를 take 하진 않더라도 그 비슷한 시간 대에 반환됩니다.<br/>

```java
package io.chagchagchag.example.foobar.spring_webflux.subscribe;

import java.util.stream.IntStream;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.BaseSubscriber;
import reactor.core.publisher.Flux;

@Slf4j
public class Subscribe5Example {
  public static void main(String[] args) {
    var subscriber = new BaseSubscriber<Integer>(){
      @Override
      protected void hookOnNext(Integer value) {
        log.info("value == " + value);
      }

      @Override
      protected void hookOnComplete() {
        log.info("completed");
      }
    };

    Flux.fromStream(IntStream.range(0, 20).boxed())
        .take(11, true)
        .subscribe(subscriber);
  }
}
```

<br/>



출력결과

```plain
19:54:18.272 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe5Example -- value == 0
19:54:18.274 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe5Example -- value == 1
19:54:18.274 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe5Example -- value == 2
19:54:18.274 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe5Example -- value == 3
19:54:18.274 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe5Example -- value == 4
19:54:18.274 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe5Example -- value == 5
19:54:18.274 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe5Example -- value == 6
19:54:18.274 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe5Example -- value == 7
19:54:18.274 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe5Example -- value == 8
19:54:18.274 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe5Example -- value == 9
19:54:18.274 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe5Example -- value == 10
19:54:18.275 [main] INFO io.chagchagchag.example.foobar.spring_webflux.subscribe.Subscribe5Example -- completed

Process finished with exit code 0
```

<br/>



## delayElements()

<br/>



## Error 

<br/>



## concat(), merge(), mergeSequential()

<br/>



## defer()

<br/>



## defer() 를 flatMap() 으로

flatMap() 에서 Supplier 동작을 하려 할 때

<br/>



## 다양한 함수들

- map(), mapNotNull()
- `doOn---()`
- flatMap()
- filter()
- take(), takeLast()
- skip(), skipLast()
- collectList()
- cache()

<br/>



## Scheduler, Thread

- ImmediateScheduler
- SingleScheduler
- ParallelScheduler
- BoundedElasticScheduler

<br/>



## Context

Context 는 파이프라인 내부의 어디에서든 접근 가능한 key, value 저장소입니다. subscribeOn, publishOn 등으로 인해 실행되는 스레드가 달라질 때 Context 를 통해서 특정 key 에 대한 value 를 조회 또는 수정할 수 있습니다.  Map 과 유사한 형식이며, Context 의 종류로는 읽기전용인 ContextView, 쓰기가능한 Context 가 있습니다.

- contextWrite() : 컨텍스트 쓰기
- contextView() : 컨텍스트 읽기
- deferContextual() 

<br/>





