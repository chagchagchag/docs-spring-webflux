## Reactor 프로그래밍 (스압 주의)

Spring Webflux 는 pivotal 사에서 개발한 project reactor 를 기반으로 한 서버 애플리케이션을 개발하기 위한 Web 프레임워크입니다.<br/>



## Flux, Mono

> 참고
>
> - Flux : [projectreactor.io - Flux](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html)
> - Mono : [projectreactor.io - Mono](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html)



- Flux : 
  - Java 의 List 와 유사한 데이터의 흐름입니다. 두개 이상의 데이터의 흐름입니다.
  - [projectreactor.io - Flux](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html) 을 보면 알 수 있듯 Publisher 를 implements 한 클래스이기에 자료구조라기보다는, 데이터의 흐름이라는 사실을 기억해주시기 바랍니다.
- Mono : 
  - 하나만 존재하는 데이터를 의미합니다.
  - [projectreactor.io - Mono](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html) 을 보면 알 수 있듯 Publisher 를 implements 한 클래스이기에 자료구조라기보다는 데이터의 흐름이라는 사실을 기억해주시기 바랍니다.

<br/>



Flux 하나만 쓰면 될것 같은데 Mono 가 존재하는 이유에 대해 생각이 들 수 있습니다. Mono 라는 자료형이 존재하는 것으로 인한 장점은 아래와 같습니다.

- 하나만 존재하는 데이터의 흐름(Response, Count 결과값 등) 일 경우 onNext 이후에 바로 onComplete 를 하면 되기 때문에 구현이 더 명확해지게 됩니다.
- Mono 라는 Publisher 를 받는 Subscriber 측 역시 1개의 요소만 처리해야 한다는 사실을 알 수 있기 때문에 조금 더 구현이 명확해집니다.

<br/>



## sequence

Mono,Flux 를 이용해서 다양한 데이터의 흐름을 만들어봅니다. Mono, Flux 를 통해서 만들어내는 데이터의 흐름을 일반적으로 `sequence` 라고 부릅니다.<br/>

<br/>



### just

Mono.just(), Flux.just() 메서드를 사용하면 시퀀스를 생성할 수 있습니다. 자세한 내용은 예제와 출력결과를 확인해주시기 바랍니다.

`JustExample.java`

```java
package io...sequence;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
public class JustExample {
  public static void main(String[] args) {
    Mono.just("안녕하세요")
        .subscribe(v -> {
          log.info(">>> {}", v);
        });

    Flux.just("MSFT", "NVDA", "SMCI")
        .subscribe(v -> {
          log.info(">>> {}", v);
        });
  }
}
```

<br/>

출력결과

```plain
15:18:07.066 [main] INFO io...sequence.JustExample -- >>> 안녕하세요
15:18:07.228 [main] INFO io...sequence.JustExample -- >>> MSFT
15:18:07.228 [main] INFO io...sequence.JustExample -- >>> NVDA
15:18:07.228 [main] INFO io...sequence.JustExample -- >>> SMCI

Process finished with exit code 0
```

<br/>



### error

Mono.error, Flux.error 를 사용하면 subscriber 에게 onError 이벤트를 전달할 수 있습니다.<br/>

반드시 **"subscriber 에게 onError 이벤트를 전달한다."**라는 의미를 꼭 기억해주셨으면 합니다.<br/>

```java
package io.chagchagchag.example.foobar.spring_webflux.sequence;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
public class ErrorExample {

  public static void main(String[] args) {
    Mono.error(new IllegalArgumentException("어머, 에러에요"))
        .subscribe(
            v -> {log.info("v ::: " + v);},
            error -> {log.error("error ::: " + error);}
        );

    Flux.error(new IllegalArgumentException("어머, 에러에요"))
        .subscribe(
            v -> {log.info("value ::: " + v);},
            error -> {log.error("error ::: " + error);}
        );
  }
}

```

<br/>



출력결과

```plain
15:27:13.589 [main] ERROR io.chagchagchag.example.foobar.spring_webflux.sequence.ErrorExample -- error ::: java.lang.IllegalArgumentException: 어머, 에러에요
15:27:13.699 [main] ERROR io.chagchagchag.example.foobar.spring_webflux.sequence.ErrorExample -- error ::: java.lang.IllegalArgumentException: 어머, 에러에요

Process finished with exit code 0
```

<br/>



### empty

Mono.empty, Flux.empty 를 써보는 예제입니다. empty 를 사용하면 Mono 또는 Flux 에게 onComplete 이벤트만 전달되게 됩니다.

```java
package io.chagchagchag.example.foobar.spring_webflux.sequence;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
public class EmptyExample {
  public static void main(String[] args) {
    Mono.empty()
        .subscribe(
            v -> {log.info("value === " +v);},
            null,
            () -> {log.info("complete");}
        );

    Flux.empty()
        .subscribe(
            v -> {log.info("value === " + v);},
            null,
            () -> {log.info("complete");}
        );
  }
}
```

<br/>



출력결과

```plain
15:31:46.735 [main] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.EmptyExample -- complete
15:31:46.792 [main] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.EmptyExample -- complete

Process finished with exit code 0
```

<br/>



### Mono.fromOOO()

Mono.from 으로 시작하는 함수들은 아래와 같습니다.

- Mono.fromCallable
  - Callable 함수형 인터페이스를 람다로 실행 후 반환값은 onNext 로 전달됩니다.
- Mono.formFuture
  - Future 를 받아서 done 상태가 되었을 때 반환값을 onNext 로 Subscriber 에 전달합니다.
- Mono.fromSupplier
  - Supplier 함수형 인터페이스를 람다로 실행 후 반환값은 onNext 로 Subscriber 에 전달합니다.
- Mono.fromRunnable
  - Runnable 함수형 인터페이스를 람다로 실행 후, onComplete 를 Subscriber 에 전달합니다.

<br/>



```java
package io.chagchagchag.example.foobar.spring_webflux.sequence;

import java.util.concurrent.CompletableFuture;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

@Slf4j
public class MonoFromExample {
  public static void main(String[] args) {
    Mono.fromCallable(() -> {
      return "삼성전자";
    }).subscribe(v -> {
      log.info("fromCallable 에서 받은 value === " + v);
    });

    Mono.fromFuture(CompletableFuture.supplyAsync(() -> {
      return "삼성전자";
    })).subscribe(v -> {
      log.info("fromFuture 로부터 받은 value === " + v);
    });

    Mono.fromSupplier(() -> {
      return "삼성전자";
    }).subscribe(v -> {
      log.info("fromSupplier 로부터 받은 value === " + v);
    });

    Mono.fromRunnable(() -> {
      log.info("do some runnable");
    }).subscribe(
        null, null, () -> {log.info("fromRunnable Complete.");}
    );
  }
}
```

<br/>



출력결과

```plain
15:45:03.043 [main] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.MonoFromExample -- fromCallable 에서 받은 value === 삼성전자
15:45:03.049 [main] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.MonoFromExample -- fromFuture 로부터 받은 value === 삼성전자
15:45:03.051 [main] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.MonoFromExample -- fromSupplier 로부터 받은 value === 삼성전자
15:45:03.052 [main] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.MonoFromExample -- do some runnable
15:45:03.052 [main] INFO io.chagchagchag.example.foobar.spring_webflux.sequence.MonoFromExample -- fromRunnable Complete.

Process finished with exit code 0
```

<br/>



### Flux.fromOOO()

Flux.from 으로 시작하는 함수들은 아래와 같습니다.

- Flux.fromIterable
- Flux.fromStream
- Flux.fromArray
- Flux.range(start, n)



```java
```

<br/>



출력결과

```plain
```

<br/>



### Flux.generate

#### 1) next()

#### 2\) next()를 두번 호출하면? 에러발생

<br/>



### Flux.create()

<br/>



### Flux.handle()

<br/>



## subscribe(), Subscriber

<br/>



## delayElements()

<br/>



## Error 

<br/>



## concat(), merge(), mergeSequential()

<br/>



## defer()

<br/>



## defer() 를 flatMap() 으로

flatMap() 에서 Supplier 동작을 하려 할 때

<br/>



## 다양한 함수들

- map(), mapNotNull()
- `doOn---()`
- flatMap()
- filter()
- take(), takeLast()
- skip(), skipLast()
- collectList()
- cache()

<br/>



## Scheduler, Thread

- ImmediateScheduler
- SingleScheduler
- ParallelScheduler
- BoundedElasticScheduler

<br/>



## Context

Context 는 파이프라인 내부의 어디에서든 접근 가능한 key, value 저장소입니다. subscribeOn, publishOn 등으로 인해 실행되는 스레드가 달라질 때 Context 를 통해서 특정 key 에 대한 value 를 조회 또는 수정할 수 있습니다.  Map 과 유사한 형식이며, Context 의 종류로는 읽기전용인 ContextView, 쓰기가능한 Context 가 있습니다.

- contextWrite() : 컨텍스트 쓰기
- contextView() : 컨텍스트 읽기
- deferContextual() 

<br/>





