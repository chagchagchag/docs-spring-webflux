## CompletableFuture, CompletionStage



## Overview

[CompletableFuture](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html) 는 [CompletionStage](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html) interface, [Future](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html) interface 를 implements 한 구체타입 클래스입니다.<br/>

![](./img/completable-future-completion-stage/completable-future.png)

<br/>



즉, **CompletableFuture** 는 이름에서 알 수 있듯 **CompletionStage** 와 **Future** 의 기능을 모두 가지고 있는 클래스입니다.<br/>

이번 문서에서는 CompletableFuture 와 CompletionStage 에 대해 알아보기 전에 제일 먼저 Future 의 기본동작과 isDone(), isCancelled() 와 같은 기본적은 메서드 들에 대해 확인해보고, CompletionStage 의 대표적인 기능들을 알아봅니다. 그리고 CompletableFuture 의 기능을 알아보면서 결국 CompletableFuture 를 사용하는 것이 좋기는 하지만 결과적으로는 어떤 한계에 부딪히는지 역시 정리합니다.<br/>

<br/>

- Future
- CompletionStage
- CompletableFuture

<br/>



## CompletableFuture 의 Thread Pool

별도로 ExecutorService 를 지정해서 CompletableFuture 를 실행하지 않으면, CompletableFuture 는 기본설정값 으로 Fork Join Pool 을 이용해서 비동기 함수들을 실행합니다.<br/>

Fork Join Pool 의 기본 Pool size 는 JVM 이 구동되는 머신의 CPU 코어수 -1 개입니다. Fork Join Pool 내에서 동작하는 스레드 들은 데몬 스레드로 동작하며, main 스레드가 종료될 경우 함께 즉시 종료됩니다.<br/>

Fork Jon Pool 은 아래와 같이 work steal 알고리즘이 적용된 방식으로 동작하며, 태스크를 sub 태스크로 fork 해서 이것들을 work, steal 하는 방식으로 동작합니다. 그리고 최종 결과는 join 을 통해서 결과가 생성됩니다.<br/>

그림 상으로는 아래와 같은 모습입니다.<br/>

![](./img/completable-future-completion-stage/fork-join-pool.png)

<br/>



만약 Fork Join Pool 이 아닌 일반적인 스레드 풀을 사용하고 싶다면 [Executors](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html) 에서 제공하는 팩토리 메서드 들을 통해 직접 생성한 ExecutorService 를 CompletableFuture 의 supplyAsync(Runnable, ExecutorService) 등과 같은 메서드 들에 직접 인자값으로 넘겨주면, 다른 종류의 스레드 풀 기반의 ExecutorService 를 사용할 수 있습니다.<br/>

<br/>



## Future

> 참고 : [Future](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html)

<br/>

[Future](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html) interface 에서 살펴볼 메서드는 isDone(), isCancelled(), get(), cancel() 메서드 입니다.<br/>

- **[isDone](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#isDone--)**()
  - isDone() 메서드는 태스크가 취소되든, 완료되었든 끝난 상태라면 true 를 반환하고 진행중이라면 false 를 리턴합니다.
- **[isCancelled](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#isCancelled--)**()
  - isCancelled() 메서드는 태스크가 취소된 경우에만 true 를 리턴하고 취소되지 않은 상태인 경우 false 를 리턴합니다.
- get()
  - **[get](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#get--)**() 
    - 작업이 끝날 때 까지 thread 가 block 됩니다.  future 에서 무한 루프나 오랜 시간이 걸릴 경우 thread 가 blocking 상태로 유지됩니다.
  - **[get](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#get-long-java.util.concurrent.TimeUnit-)**(long timeout, [TimeUnit](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/TimeUnit.html) unit)
    - timeout 동안 thread 가 block 됩니다. timeout 이 넘어가면 TimeoutException 이 throw 됩니다.
- cancel()
  - **[cancel](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#cancel-boolean-)**(boolean mayInterruptIfRunning)
    - future 의 작업을 취소합니다.
    - mayInterruptIfRunning 을 false 로 지정하면, 시작하지 않은 작업에 대해서만 취소를 합니다.
    - 취소할 수 없는 상황일 경우(e.g. myInterruptIfRunning 이 false 인데 이미 시작한 작업일 경우)에는 false 를 return 합니다.

<br/>



### Future interface 의 단점

cancel() 과 같은 메서드가 아니라면, 외부에서 future 를 제어할 방법이 없습니다. 또한 get() 메서드의 블로킹 기반의 연산으로 값을 얻어온 후 연산을 처리하며, 비동기적으로 데이터를 처리하려면 프로그래머가 직접 그 코드를 하드코딩해서 만들어야합니다.<br/>

또한 isDone(), isCancelled() 의 경계가 모호함으로 인해 완료되었는지, 에러가 발생했는지를 명확하게 확인하기 쉽지 않다는 단점이 있습니다.

```java
package INFO io...concurrent.sync_async.future;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import lombok.SneakyThrows;

public class Future_Disadvantage_Example1 {
  @SneakyThrows
  public static void main(String[] args) {
    Future<String> future1 = getFuture();
    future1.cancel(true); // 이미 실행 중이라면 Interrupt 한다.
    assert future1.isDone(); // cancel 했지만, isDone() == true

    Future<String> future2 = getFutureWithException();
    Exception exception = null;
    try{
      future2.get();
    }
    catch (Exception e){
      exception = e;
    }

    assert future2.isDone();
    assert exception != null;
  }

  @SneakyThrows
  public static Future<String> getFuture(){
    ExecutorService executor = Executors.newSingleThreadExecutor();
    try{
      return executor.submit(() -> {
        return "안녕하세요";
      });
    }
    catch (Exception e){
      e.printStackTrace();
      throw new RuntimeException(e);
    }
    finally {
      executor.shutdown();
    }
  }

  @SneakyThrows
  public static Future<String> getFutureWithException(){
    ExecutorService executor = Executors.newSingleThreadExecutor();
    try{
      return executor.submit(() -> {
        throw new RuntimeException("배고파요");
      });
    }
    catch (Exception e){
      e.printStackTrace();
      throw new RuntimeException(e);
    }
    finally {
      executor.shutdown();
    }
  }
}
```

<br/>



반면 CompletableStage 는 thenAsync(), thenCompose(), supplyAsync() 와 같은 메서드를 통해 체이닝을 통해 비동기적인 프로그래밍을 제공합니다. 여기에 대해서는 다음 섹션에서 정리합니다.<br/>

<br/>



### 예제

#### get()

- **[get](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#get--)**() 
  - 작업이 끝날 때 까지 thread 가 block 됩니다.  future 에서 무한 루프나 오랜 시간이 걸릴 경우 thread 가 blocking 상태로 유지됩니다.
- **[get](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#get-long-java.util.concurrent.TimeUnit-)**(long timeout, [TimeUnit](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/TimeUnit.html) unit)
  - timeout 동안 thread 가 block 됩니다. timeout 이 넘어가면 TimeoutException 이 throw 됩니다.



> 예제의 설명은 주석으로 추가해두었습니다.

```java
package INFO io...concurrent.sync_async.future;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class FutureGet_Methods_Example1 {
  @SneakyThrows
  public static void main(String[] args) {
    // get()
    Future<String> future1 = getFutureWithDelay1s();
    assert !future1.isDone();
    assert !future1.isCancelled();

    // 블로킹 방식의 동기연산. 값을 얻어옵니다.
    String result1 = future1.get(); // 1초 소요
    assert result1.equals("안녕하세요");
    assert future1.isDone(); // 작업은 완료되었기에 true 를 return
    assert !future1.isCancelled(); // 취소된 적 없으므로 false 를 return

    // get(timeout, TimeUnit)
    Future<String> future2 = getFutureWithDelay1s(); // 1초 소요
    String result2 = future2.get(2000, TimeUnit.MILLISECONDS); // 2초 안에 마무리 되므로 정상수행
    assert result2.equals("안녕하세요"); // 값을 제대로 받아왔습니다.

    // 이번에는 long running 작업의 timeout 적용 코드
    Future<String> future3 = getFutureWithDelay1s(); // 1초 소요
    Exception exception = null; // exception 객체
    String result3 = null;

    try{
      result3 = future3.get(10, TimeUnit.MILLISECONDS); // 10ms 안에 마무리 되지 않으므로 TimeoutException throw
    } catch (Exception e){
      exception = e;
    }
    assert exception != null;
    assert result3 == null;
    log.info("exception = " + exception);
  }

  @SneakyThrows
  public static Future<String> getFutureWithDelay1s(){
    ExecutorService executor = Executors.newSingleThreadExecutor();
    try{
      return executor.submit(() -> {
        Thread.sleep(1000);
        return "안녕하세요";
      });
    }
    catch (Exception e){
      e.printStackTrace();
      throw new RuntimeException(e);
    }
    finally {
      executor.shutdown();
    }
  }
}
```

<br/>



출력결과

```plain
15:05:27.647 [main] INFO io...concurrent.sync_async.future.FutureMethods_Example1 -- exception = java.util.concurrent.TimeoutException

Process finished with exit code 0
```

<br/>



#### cancel(), isDone(), isCancelled()

**[cancel](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#cancel-boolean-)**(boolean mayInterruptIfRunning)

- future 의 작업을 취소합니다.
- mayInterruptIfRunning 을 false 로 지정하면, 시작하지 않은 작업에 대해서만 취소를 합니다.
- 취소할 수 없는 상황일 경우(e.g. myInterruptIfRunning 이 false 인데 이미 시작한 작업일 경우)에는 false 를 return 합니다.

**[isDone](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#isDone--)**()

- isDone() 메서드는 태스크가 취소되든, 완료되었든 끝난 상태라면 true 를 반환하고 진행중이라면 false 를 리턴합니다.

**[isCancelled](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#isCancelled--)**()

- isCancelled() 메서드는 태스크가 취소된 경우에만 true 를 리턴하고 취소되지 않은 상태인 경우 false 를 리턴합니다.



> 예제의 설명은 주석으로 추가해두었습니다.

```java
package INFO io...concurrent.sync_async.future;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class FutureCancel_Methods_Example1 {
  @SneakyThrows
  public static void main(String[] args) {
    Future<String> future1 = getFuture();
    Boolean isCancelled1 = future1.cancel(true);
    // mayInterruptIfRunning = true 의 의미 :: 작업이 진행 중이면 Interrupt 하겠다.

    assert future1.isCancelled();
    assert future1.isDone();
    assert isCancelled1 == true;

    // 이미 존재하는 Future 를 Cancel
    Boolean isCancelled2 = future1.cancel(true);
    assert future1.isCancelled();
    assert future1.isDone(); // cancel() 된 작업도 isDone() == true 로 간주
    assert isCancelled2 == false;
  }

  @SneakyThrows
  public static Future<String> getFuture(){
    ExecutorService executor = Executors.newSingleThreadExecutor();
    try{
      return executor.submit(() -> {
        return "안녕하세요";
      });
    }
    catch (Exception e){
      e.printStackTrace();
      throw new RuntimeException(e);
    }
    finally {
      executor.shutdown();
    }
  }
}
```

<br/>



## CompletionStage

> 참고 : [CompletionStage](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html) 

CompletableStage interface 에서 살펴볼 주요 메서드 들은 아래와 같습니다.<br/>

(출처 : [github.com/JetBrains/jdk8u_jdk](https://github.com/JetBrains/jdk8u_jdk/blob/master/src/share/classes/java/util/concurrent/CompletionStage.java))

```java
package java.util.concurrent;
// ...
public interface CompletionStage<T> {
    public <U> CompletionStage<U> thenApply(Function<? super T,? extends U> fn);
    public <U> CompletionStage<U> thenApplyAsync
        (Function<? super T,? extends U> fn);
    public <U> CompletionStage<U> thenApplyAsync
        (Function<? super T,? extends U> fn,
         Executor executor);
    
    public CompletionStage<Void> thenAccept(Consumer<? super T> action);
    public CompletionStage<Void> thenAcceptAsync(Consumer<? super T> action);
    public CompletionStage<Void> thenAcceptAsync(Consumer<? super T> action,
                                                 Executor executor);
    
    
    public CompletionStage<Void> thenRun(Runnable action);
    public CompletionStage<Void> thenRunAsync(Runnable action);
    public CompletionStage<Void> thenRunAsync(Runnable action,
                                              Executor executor);
    
    // ...
    
    public <U> CompletionStage<U> thenCompose
        (Function<? super T, ? extends CompletionStage<U>> fn);
    public <U> CompletionStage<U> thenComposeAsync
        (Function<? super T, ? extends CompletionStage<U>> fn);
    public <U> CompletionStage<U> thenComposeAsync
        (Function<? super T, ? extends CompletionStage<U>> fn,
         Executor executor);
    
    // ...
    
    public CompletionStage<T> exceptionally
        (Function<Throwable, ? extends T> fn);
    
}
```

<br/>



CompletionStage 는 위의 메서드 들 외에도 굉장히 다양하고 많은 메서드 들을 제공하고 있습니다. 이 메서드 들을 활용하면 태스크 들을 비동기적으로 실행하고 값을 조작하거나 체이닝이 가능해집니다. <br/>

또한 람다를 인자로 받아서 콜백처럼 동작하는 것 역시 가능합니다.<br/>

CompletionStage 내에서 제공하는 주요 메서드 들은 Java8 부터 제공하기 시작한 기본 함수형 인터페이스를 인자로 취하며 네이밍 컨벤션 역시 thenAccept(), thenApply() 드역시 어느 정도 비슷하기에 이 함수가 어떤 역할을 하는지 인자값은 어떻게 되는지 유추하기 명확합니다.

- CompletableFuture::thenAccept(Consumer)
- CompletableFuture::thenApply(Function)
- CompletableFuture::thenCompose(Function)
- CompletableFuture::thenRun(Runnable)

<br/>



### then`---`(), then`---`Async() 의 차이점

`then---()` 를 실행할 때에는 `then---()` 를 호출한 caller 의 실행 스레드가 `then---()` 메서드를 실행하게 됩니다.<br/>

`then---Async()` 를 실행할 때에는 `then---Async()` 를 호출한 caller 의 실행 스레드에서 실행되지 않고 별도의 스레드에서 `then---Async()`를 실행합니다.<br/>

<br/>



### thenAccept(Consumer), thenAcceptAsync(Consumer)

thenAccept(Consumer), thenAcceptAsync(Consumer) 는 함수형 인터페이스 Consumer 를 인자값으로 받습니다. Consumer 는 그 이름에서 알 수 있듯 값을 받은 후 소비를 합니다. 리턴값은 없습니다.

![](./img/completable-future-completion-stage/consumer.png)

<br/>

thenAccept(Consumer) 를 실행할 때에는 thenAccept(Consumer) 를 호출한 caller 의 실행 스레드가 thenAccept(Consumer) 메서드를 실행하게 됩니다.<br/>

thenAcceptAsync(Consumer) 를 실행할 때에는 thenAcceptAsync(Consumer) 를 호출한 caller 의 실행 스레드에서 실행되지 않고 별도의 스레드에서 thenAcceptAsync(Consumer)를 실행합니다.<br/>

<br/>



#### thenAccept(Consumer)

thenAccept(Consumer) 가 어느 스레드에서 실행되는지 로그를 찍어보는 예제입니다.<br/>

```java
package INFO io...concurrent.sync_async.completion_stage.consumer;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class ThenAccept_Example1 {
  @SneakyThrows
  public static void main(String[] args) {
    log.info("[start] main");
    CompletionStage<String> stage = stage();

    stage
        .thenAccept(msg -> {
          log.info("[thenAccept (1)] msg :: " + msg + "");
        })
        .thenAccept(msg -> {
          log.info("[thenAccept (2)] msg :: " + msg + "");
        });

    Thread.sleep(1000);
    log.info("[end] main");
  }

  @SneakyThrows
  public static CompletionStage<String> stage(){
    var future = CompletableFuture.supplyAsync(() -> {
      log.info("CompletableFuture 내부");
      return "안녕하세요";
    });

    Thread.sleep(1000);
    return future;
  }
}
```

<br/>



결과를 확인해보면, 아래와 같이 supplyAsync() 를 실행할때를 제외하고, 모든 호출구문이 main 에서 실행되고 있습니다. thenAccept(Consumer) 를 호출하는 부분 역시 main 스레드에서 실행되었음을 확인 가능합니다.<br/>

<br/>



출력결과

```plain
19:04:59.708 [main] INFO INFO io...concurrent.sync_async.completion_stage.consumer.ThenAccept_Example1 -- [start] main
19:04:59.714 [ForkJoinPool.commonPool-worker-1] INFO INFO io...concurrent.sync_async.completion_stage.consumer.ThenAccept_Example1 -- future 내부
19:05:00.722 [main] INFO INFO io...concurrent.sync_async.completion_stage.consumer.ThenAccept_Example1 -- [thenAccept (1)] msg :: 안녕하세요
19:05:00.723 [main] INFO INFO io...concurrent.sync_async.completion_stage.consumer.ThenAccept_Example1 -- [thenAccept (2)] msg :: null
19:05:01.735 [main] INFO INFO io...concurrent.sync_async.completion_stage.consumer.ThenAccept_Example1 -- [end] main

Process finished with exit code 0
```

<br/>



#### thenAcceptAsync(Consumer)

thenAcceptAsync(Consumer) 가 어느 스레드에서 실행되는지 로그를 찍어보는 예제입니다.<br/>

```java
package io.chagchagchag.example.foobar.concurrent.sync_async.completion_stage.consumer;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class ThenAcceptAsync_Example {
  @SneakyThrows
  public static void main(String[] args) {
    log.info("[start] main");
    CompletionStage<String> stage = stage();
    stage
        .thenAcceptAsync(msg -> {
          log.info("[thenAccept (1)] msg :: " + msg + "");
        })
        .thenAcceptAsync(msg -> {
          log.info("[thenAccept (2)] msg :: " + msg + "");
        });

    Thread.sleep(1000);
    log.info("[end] main");
  }

  @SneakyThrows
  public static CompletionStage<String> stage(){
    var future = CompletableFuture.supplyAsync(() -> {
      log.info("CompletableFuture 내부");
      return "안녕하세요";
    });

    Thread.sleep(1000);
    return future;
  }
}
```

<br/>



출력결과를 보면 thenAcceptAsync(Consumer) 구문은 `ForkJoinPool.commonPool-worker-1` 에서 실행되고 메인스레드와는 다른 스레드에서 별도로 실행되고 있다는 사실을 알 수 있습니다.<br/>



출력결과

```plain
19:09:16.839 [main] INFO INFO io...concurrent.sync_async.completion_stage.consumer.ThenAcceptAsync_Example -- [start] main
19:09:16.854 [ForkJoinPool.commonPool-worker-1] INFO INFO io...concurrent.sync_async.completion_stage.consumer.ThenAcceptAsync_Example -- future 내부
19:09:17.864 [ForkJoinPool.commonPool-worker-1] INFO INFO io...concurrent.sync_async.completion_stage.consumer.ThenAcceptAsync_Example -- [thenAccept (1)] msg :: 안녕하세요
19:09:17.865 [ForkJoinPool.commonPool-worker-1] INFO INFO io...concurrent.sync_async.completion_stage.consumer.ThenAcceptAsync_Example -- [thenAccept (2)] msg :: null
19:09:18.871 [main] INFO INFO io...concurrent.sync_async.completion_stage.consumer.ThenAcceptAsync_Example -- [end] main

Process finished with exit code 0
```

<br/>



### thenApply(Function), thenApplyAsync(Function)

thenApply(Function), thenApplyAsync(Function) 는 함수형 인터페이스 Function 을 인자값으로 받습니다. Function 은 실무에서 많이 접하셨겠지만, 입력값 T 에 대해서 출력(Return)값 R 을 return 합니다.

![](./img/completable-future-completion-stage/function.png)

<br/>

thenApply(Function) 을 실행할 때에는 thenApply(Function) 을 호출한 caller 의 실행 스레드가 thenApply(Function) 메서드를 실행하게 됩니다.<br/>

thenApplyAsync(Function) 를 실행할 때에는 thenApplyAsync(Function) 를 호출한 caller 의 실행 스레드에서 실행되지 않고 별도의 스레드에서 thenApplyAsync(Function) 를 실행합니다.<br/>

<br/>



#### thenApplyAsync(Function)

```java
package io.chagchagchag.example.foobar.concurrent.sync_async.completion_stage.function;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class ThenApplyAsync_Example1 {
  @SneakyThrows
  public static void main(String[] args) {
    log.info("[start] main");
    CompletionStage<String> stage = stage();

    stage
        .thenApplyAsync(msg -> {
          String mapping = msg + " 오늘은 날씨가 흐리네요.";
          log.info("thenApplyAsync (1) ::: " + msg);
          return mapping;
        })
        .thenApplyAsync(msg -> {
          String mapping = msg + " 감기 조심하세요";
          log.info("thenApplyAsync (2) ::: " + msg);
          return mapping;
        })
        .thenApplyAsync(msg -> {
          int length = msg.length();
          log.info("length ::: " + length);
          return length;
        })
        .thenAcceptAsync(length -> {
          log.info("length ::: " + length);
        });

    Thread.sleep(300);
    log.info("[end] main");
  }

  public static CompletionStage<String> stage(){
    return CompletableFuture.supplyAsync(() -> {
      log.info("CompletableFuture::supplyAsync 내부");
      return "안녕하세요.";
    });
  }
}
```

<br/>



출력결과

```plain
08:17:04.489 [main] INFO io...concurrent.sync_async.completion_stage.function.ThenApplyAsync_Example1 -- [start] main
08:17:04.493 [ForkJoinPool.commonPool-worker-1] INFO io...concurrent.sync_async.completion_stage.function.ThenApplyAsync_Example1 -- CompletableFuture::supplyAsync 내부
08:17:04.496 [ForkJoinPool.commonPool-worker-1] INFO io...concurrent.sync_async.completion_stage.function.ThenApplyAsync_Example1 -- thenApplyAsync (1) ::: 안녕하세요.
08:17:04.496 [ForkJoinPool.commonPool-worker-1] INFO io...concurrent.sync_async.completion_stage.function.ThenApplyAsync_Example1 -- thenApplyAsync (2) ::: 안녕하세요. 오늘은 날씨가 흐리네요.
08:17:04.499 [ForkJoinPool.commonPool-worker-1] INFO io...concurrent.sync_async.completion_stage.function.ThenApplyAsync_Example1 -- length ::: 29
08:17:04.499 [ForkJoinPool.commonPool-worker-1] INFO io...concurrent.sync_async.completion_stage.function.ThenApplyAsync_Example1 -- length ::: 29
08:17:04.804 [main] INFO io...concurrent.sync_async.completion_stage.function.ThenApplyAsync_Example1 -- [end] main

Process finished with exit code 0
```

<br/>



### thenCompose(Function), thenComposeAsyc(Function)

thenCompose(Function), thenComposeAsync(Function) 는 함수형 인터페이스 Function 을 인자값으로 받습니다. Function 은 실무에서 많이 접하셨겠지만, 입력값 T 에 대해서 출력(Return)값 R 을 return 합니다.

![](./img/completable-future-completion-stage/function.png)

<br/>

thenCompose(Function) 을 실행할 때에는 thenCompose(Function) 을 호출한 caller 의 실행 스레드가 thenCompose(Function) 메서드를 실행하게 됩니다.<br/>

thenComposeAsync(Function) 를 실행할 때에는 thenComposeAsync(Function) 를 호출한 caller 의 실행 스레드에서 실행되지 않고 별도의 스레드에서 thenComposeAsync(Function) 를 실행합니다.<br/>

<br/>



#### thenComposeAsync(Function)

```java
package io.chagchagchag.example.foobar.concurrent.sync_async.completion_stage.function;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class ThenComposeAsync_Example1 {
  @SneakyThrows
  public static void main(String[] args) {
    CompletionStage<String> stage = stage();
    stage
        .thenComposeAsync(msg -> {
          CompletionStage<String> result = append(msg, " 안녕하세요");
          return result;
        })
        .thenComposeAsync(msg -> {
          CompletionStage<Integer> result = length(msg);
          return result;
        })
        .thenAcceptAsync(value -> {
          log.info("thenAcceptAsync, value = " + value);
        });

    Thread.sleep(1000);
  }

  public static CompletionStage<String> stage(){
    return CompletableFuture.supplyAsync(() -> {
      log.info("CompletableFuture::supplyAsync 내부");
      return "안녕하세요.";
    });
  }

  public static CompletionStage<String> append(String source, String postfix){
    return CompletableFuture.supplyAsync(() -> {
      sleep(100);
      return source + postfix;
    });
  }

  public static CompletionStage<Integer> length(String source){
    return CompletableFuture.supplyAsync(() -> {
      sleep(100);
      return source.length();
    });
  }

  @SneakyThrows
  public static void sleep(long ms){
    try{
      Thread.sleep(100);
    }
    catch (Exception e){
      e.printStackTrace();
    }
  }
}
```

<br/>



출력결과

```plain
09:21:54.642 [ForkJoinPool.commonPool-worker-1] INFO io...concurrent.sync_async.completion_stage.function.ThenComposeAsync_Example1 -- CompletableFuture::supplyAsync 내부
09:21:54.863 [ForkJoinPool.commonPool-worker-2] INFO io...concurrent.sync_async.completion_stage.function.ThenComposeAsync_Example1 -- thenAcceptAsync, value = 12

Process finished with exit code 0
```

<br/>



### thenRun(Runnable), thenRunAsync(Runnable)

thenRun(Runnable), thenRunAsync(Runnable) 는 함수형 인터페이스 Runnable 을 인자값으로 받습니다. 

![](./img/completable-future-completion-stage/runnable.png)

<br/>

thenRun(Runnable) 을 실행할 때에는 thenRun(Runnable) 을 호출한 caller 의 실행 스레드가 thenRun(Runnable) 메서드를 실행하게 됩니다.<br/>

thenRunAsync(Runnable) 를 실행할 때에는 thenRunAsync(Runnable) 를 호출한 caller 의 실행 스레드에서 실행되지 않고 별도의 스레드에서 thenRunAsync(Runnable) 를 실행합니다.<br/>

<br/>



#### thenRunAsync(Runnable)

```java
package io.chagchagchag.example.foobar.concurrent.sync_async.completion_stage.runnable;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class ThenRunAsync_Example {
  public static void main(String[] args) {
    log.info("[start] main");
    CompletionStage<String> stage = stage();

    stage
        .thenRunAsync(() -> {
          log.info("thenRunAsync() (1)");
        })
        .thenRunAsync(() -> {
          log.info("thenRunAsync() (2)");
        })
        .thenAcceptAsync(v -> {
          log.info("thenAcceptAsync :: " + v);
        });

    log.info("[end] main");
    sleep(100);
  }

  public static CompletionStage<String> stage(){
    var future = CompletableFuture.supplyAsync(() -> {
      log.info("CompletableFuture 내부");
      return "안녕하세요";
    });
    return future;
  }

  @SneakyThrows
  public static void sleep(long ms){
    Thread.sleep(ms);
  }
}
```

<br/>



출력결과

```plain
09:33:06.916 [main] INFO io...concurrent.sync_async.completion_stage.runnable.ThenRunAsync_Example -- [start] main
09:33:06.922 [ForkJoinPool.commonPool-worker-1] INFO io...concurrent.sync_async.completion_stage.runnable.ThenRunAsync_Example -- CompletableFuture 내부
09:33:06.923 [ForkJoinPool.commonPool-worker-1] INFO io...concurrent.sync_async.completion_stage.runnable.ThenRunAsync_Example -- thenRunAsync() (1)
09:33:06.923 [ForkJoinPool.commonPool-worker-1] INFO io...concurrent.sync_async.completion_stage.runnable.ThenRunAsync_Example -- thenRunAsync() (2)
09:33:06.924 [main] INFO io...concurrent.sync_async.completion_stage.runnable.ThenRunAsync_Example -- [end] main
09:33:06.924 [ForkJoinPool.commonPool-worker-1] INFO io...concurrent.sync_async.completion_stage.runnable.ThenRunAsync_Example -- thenAcceptAsync :: null

Process finished with exit code 0
```

<br/>



### exceptionally





## CompletableFuture







