## kafka 의 주요 개념들

![](./img/kafka-basic/kafka-broker-clustering-1.png)

<br/>



## Kafka 의 주요 특징

1. **분산 시스템:**
   - Kafka는 여러 브로커(서버)로 구성된 분산 시스템입니다. 이는 확장성을 지원하며 높은 부하와 대량의 데이터를 처리할 수 있도록 합니다.
2. **고가용성 및 복제:**
   - Kafka는 데이터의 고가용성을 보장하기 위해 데이터를 여러 브로커에 복제합니다. 따라서 하나의 브로커에 장애가 발생하더라도 데이터 손실 없이 서비스를 지속할 수 있습니다.
   - 데이터의 복제본을 여러 서버에 분산시켜서 저장하기에 서버하나가 실패하더라도 데이터 손실을 방지할 수 있다는 것은 장점입니다. 
   - 고가용성은 시스템이 장애나 오류에 강건하게 대응하고 지속적으로 운영되며 사용가능한 상태를 유지하는 능력을 의미합니다. 고가용성이 높은 시스템은 사용자에게 지속적인 서비스를 제공할 수 있으며 장애 발생 시에도 데이터의 손실을 최소화 하고 빠른 회복을 할 수 있습니다.
3. **고성능:**
   - Kafka는 대용량 데이터 처리를 목표로 하기 때문에 높은 성능을 제공합니다. 특히 디스크에 기록하면서도 낮은 지연 시간을 유지할 수 있습니다.
4. **스트림 처리:**
   - Kafka는 데이터를 실시간으로 처리할 수 있도록 스트림 처리를 지원합니다. Kafka Streams API를 사용하면 데이터에 대한 복잡한 연산을 수행하고 결과를 생성할 수 있습니다.
5. **확장성:**
   - 새로운 브로커를 추가함으로써 Kafka 클러스터의 용량을 쉽게 확장할 수 있습니다. 이는 시스템의 요구 사항이 변할 때 유연하게 대응할 수 있음을 의미합니다.
6. **유연한 보관 및 보존:**
   - Kafka는 데이터를 보관하고 기간별로 데이터를 보존할 수 있습니다. 이는 영구적인 데이터 저장과 이력 추적에 유용합니다.
7. **토픽 기반 메시지 시스템:**
   - Kafka는 토픽을 사용하여 메시지를 구분하고 구독하는 방식을 채택합니다. 이를 통해 데이터의 흐름을 조직화하고 특정 주제에 대한 데이터를 관리할 수 있습니다.
8. **다양한 클라이언트 지원:**
   - Kafka는 다양한 언어로 구현된 클라이언트를 지원하며, 프로듀서 및 컨슈머를 통한 데이터 흐름을 구축하기 위한 다양한 라이브러리를 제공합니다.

<br/>



## 토픽

![](./img/kafka-basic/what-is-topic.png)

메시지를 적재하거나 구독할 수 있는 하나의 메시지 대기열 같은 개념입니다. 토픽은 파티션 1개로만 운영할 수도 있고 여러개의 파티션으로 나누어 운영할 수 도 있습니다. <br/>

파티션을 1개로 구성할 경우 컨슈머 랙 증상이 발생할 수 있기 때문에 파티션을 여러개로 구성해서 사용하는 경우가 많습니다.<br/>

일반적으로는 토픽 하나에 파티션을 여러 개 두어서 컨슈머 랙 증상을 방지하는 편입니다.<br/>

![](./img/kafka-basic/consumer-numu-mana.png)

여러 개의 파티션으로 나눌 경우 각 파티션을 바라봐야 할 컨슈머 개수도 파티션의 개수에 맞춰서 운영합니다. 그런데 파티션의 개수보다 컨슈머의 수가 더 많을 경우 일부 컨슈머는 파티션을 할당받지 못하고 대기 상태가 됩니다. 위의 그림에서는 초록색 배경으로 표시한 컨슈머가 유휴상태에 진입했네요. 컨슈머와 컨슈머 그룹, 컨슈머 리밸런싱에 대해서는 뒤에서 따로 정리합니다.<br/>

<br/>



## 메시지, 프로듀서, 컨슈머, 컨슈머 그룹

**메시지**<br/>

토픽에 적재되는 개별 데이터를 메시지라고 합니다. 메시지는 key, value, timestamp 로 구성됩니다. <br/>

<br/>



**프로듀서**<br/>

토픽에 데이터를 적재하는 역할을 합니다.<br/>

프로듀서는 여러가지 언어로 작성 가능합니다.<br/>

<br/>



**컨슈머**<br/>

컨슈머는 토픽을 구독해서 메시지를 읽어들이는 역할을 수행합니다. 보통 컨슈머의 개수는 파티션의 개수에 맞춰서 띄웁니다.<br/>

<br/>



**컨슈머 그룹**<br/>

보통 토픽을 파티션 1개로만 운영하는 경우가 없기때문에 여러개의 파티션으로 구성하는데, 이렇게 파티션을 여러개로 나누어 둔 경우 컨슈머 역시 파티션 갯수에 맞춰서 띄웁니다. 그리고 띄운 컨슈머들을 하나의 그룹으로 묶어서 하나의 그룹으로 인식하는데 이것을 컨슈머 그룹이라고 합니다..<br/>

<br/> 

## 컨슈머 랙

![](./img/kafka-basic/consumer-lag.png)

컨슈머는 토픽을 구독해서 메시지를 읽어들입니다.  그런데 프로듀서가 메시지를 발행하는 속도에 비해 컨슈머가 메시지를 읽어서 처리하는 속도가 느릴 경우 점점 컨슈머의 오프셋이 가장 최신 오프셋으로부터 멀어지게 됩니다. 이렇게 컨슈머의 읽기 속도가 메시지 발급속도를 따라가지 못하는 현상을 **"컨슈머 랙(Consumer Lag)"** 이라고 부릅니다.<br/>

<br/>



## 파티션과 컨슈머 그룹

컨슈머 랙 증상은 토픽을 여러 개의 파티션으로 구성하고 각각의 파티션을 구독하는 컨슈머들을 파티션 갯수만큼 띄우는 것으로 해결이 가능합니다.

![](./img/kafka-basic/partition-and-consumer-group.png)

**파티션**<br/>

파티션은 토픽을 여러개로 나눈 토픽 내부의 메시지 대기열을 의미합니다. 파티션은 프로듀서가 보내는 메시지의 메시지 키 값에 의해 파티션이 선택됩니다. 이 메시지 키 값을 지정하지 않고 메시지를 전송할 경우 내부적으로 라운드 로빈 방식으로 파티션을 선택해서 데이터를 전송하게 됩니다.<br/>

위의 그림은 파티션 키 알고리즘을 메시지 키가 정수일 때 홀수/짝수인지에 따라서 파티션이 선택되도록 한 경우로 지정했을 경우에 대한 그림입니다. 실무에서는 파티션 키를 제품의 키를 기준으로 한다던가 등등 여러가지 케이스들이 있습니다.<br/>

<br/>



**컨슈머 그룹**<br/>

하나의 토픽 내에 파티션을 각각 하나씩 바라보는 컨슈머들을 하나의 그룹으로 묶을 수 있는데 이것을 컨슈머 그룹이라고 합니다. 컨슈머 그룹은 여러개를 운영하는 것이 가능합니다. <br/>

만약 토픽 하나에 대한 파티션 개수보다 컨슈머 그룹내의 컨슈머 개수가 더 많다면 어떻게 될까요? 이런 경우 놀고 있는(유휴(Idle)) 상태의 컨슈머가 생기게 됩니다. 장애로 이어지지는 않지만 자원 낭비가 생기게 됩니다.<br/>

<br/>



## 순서가 중요한 메시지일 경우

순차적인 메시지 처리를 하게끔 해야 하는 경우가 있습니다. 이런 경우 어떻게 하면 문제를 해결할 수 있는지를 정리해봅니다.

![](./img/kafka-basic/message-handling-by-event-order-1.png)

토픽을 여러 개의 파티션으로 파티셔닝하면 메시지가 순차적으로 처리는 것을 보장하지 못하게 됩니다. <br/>

예를 들어서 **주문완료 → 결제완료 → 상품준비중** 의 순서로 메시지를 보내야 하는 경우가 있습니다.<br/>

만약 파티션 알고리즘에 따라 처리하거나, 기본 설정인 라운드 로빈 방식으로 처리할 경우 주문완료 메시지는 파티션 1에, 결제완료는 파티션 2에, 상품 준비중 이벤트는 파티션1에 쌓이게 되어서 메시지가 순차적으로 전달되지 않을 수 있습니다.<br/>



![](./img/kafka-basic/message-handling-by-event-order-2.png)

이런 경우 특정 상품을 장바구니에서 주문/결제 하는 기능에 대해서는 특정 파티션을 선택해서 메시지를 전송하게끔 하는 것으로 이런 문제를 해결 가능합니다.<br/>

<br/>



## 카프카 브로커

카프카 브로커는 토픽들과 파티션들을 가지고 운영하고 있는 하나의 물리적인 서버를 의미합니다. 

> 어쩌다 보니 그림이 너무 크게 추출되었는데 그림 사이즈 수정하는 도구를 찾아서 문제를 해결하겠습니다!!! 

![](./img/kafka-basic/what-is-broker.png)

<br/>



## 카프카 브로커 클러스터링

몽고DB의 레플리카셋, 샤드 클러스터를 구성해보셨거나 k8s 앱을 작성해보신 분들이라면 클러스터링이라는 것이 무엇을 의미하는지 아실 겁니다. 카프카 브로커 역시 클러스터링이 가능합니다.<br/>

![](./img/kafka-basic/kafka-broker-clustering-1.png)

위의 그림에서 보듯 주키퍼(zookeeper)를 통해서 브로커들의 상태를 관리하고, 리더파티션 선출, 메타데이터 관리 등의 역할을 합니다. 주키퍼(zookeeper) 역시 클러스터링이 가능합니다.<br/>



## 카프카 브로커 장애 발생시 리더 파티션 재선출

![](./img/kafka-basic/kafka-broker-clustering-2.png)



위의 그림에서는 1번 브로커 에서 장애가 생겼습니다. 브로커 1 에는 파티션 1을 리더 파티션으로 운영되고 있었습니다. 이렇게 장애가 생긴 경우 주키퍼(zookeeper)가 브로커들의 상태를 체크하고 있다가 장애를 파악하면 리더 파티션을 투표를 통해서 선출하게 되는데요. 위의 그림에서는 2번 브로커 내의 1번 파티션이 리더로 선출된 것을 확인 가능합니다.<br/>

참고로 주키퍼(zookeeper) 역시 클러스터링이 가능합니다.<br/>

<br/>
